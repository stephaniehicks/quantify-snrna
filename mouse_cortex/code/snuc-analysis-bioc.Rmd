---
title: "single-nucleus analysis (mouse cortex)"
author: "Albert Kuo and Stephanie Hicks"
date: "9/8/2020"
output: 
  html_document:
    code_folding: "hide"
    toc: TRUE
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

  ## Exploratory Analysis

```{r}
suppressPackageStartupMessages({
  library(here)
  library(tidyverse)
  library(tictoc)
  library(scran)
  library(scater)
  library(BiocSingular)
  library(SingleCellExperiment)
})
```

```{r}
run_number = "all" # give run_number or "all" for all of them together
sce_ls = list()
sce_ls[["transcripts"]] = readRDS(here("mouse_cortex", "salmon_quants", "transcripts_pipeline", paste0("sce_", run_number, ".rds")))
sce_ls[["preandmrna"]] = readRDS(here("mouse_cortex", "salmon_quants", "preandmrna_pipeline", paste0("sce_", run_number, ".rds")))
sce_ls[["introncollapse"]] = readRDS(here("mouse_cortex", "salmon_quants", "introncollapse_pipeline", paste0("sce_", run_number, ".rds")))
sce_ls[["intronseparate"]] = readRDS(here("mouse_cortex", "salmon_quants", "intronseparate_pipeline", paste0("sce_", run_number, ".rds")))
```

### Quality control

Discard low-quality cells and convert from SummarizedExperiment to SingleCellExperiment. Done in `save-sce.R`.

### Mapping differences

#### Library size comparison

To generate and save these plots, run `libsize-plots.R`.

```{r}
# Get library sizes
lib_sizes_ls = list()
for(i in seq_along(sce_ls)){
  sce = sce_ls[[i]]
  pipeline = names(sce_ls)[i]
  
  lib_sizes_ls[[pipeline]] = colData(sce) %>%
    as_tibble() %>%
    mutate(cell_barcode = rownames(colData(sce)),
           pipeline = pipeline)
}

lib_sizes = bind_rows(lib_sizes_ls)

# Compute median label
summ = lib_sizes %>% 
  group_by(pipeline, cortex) %>% 
  summarize(median = median(lib_size))

# Plot library size comparison between pipelines
p = lib_sizes %>%
  ggplot(aes(x = factor(pipeline, levels = c("transcripts", "preandmrna", "introncollapse", "intronseparate")), y = lib_size)) +
  geom_boxplot() + 
  # geom_text(data = summ, aes(x = pipeline, y = median, 
                              # label = round(median, 0)), 
            # vjust = -0.5, size = 2.5) +
  facet_wrap(~ cortex) +
  labs(x = "Pipeline",
       y = "Library size") +
  theme_bw() +
  theme(axis.text = element_text(size = 8))
print(p)

# ggsave(file = here(paste0("./mouse_cortex/plots/lib_size_comparison.png")),
#        plot = p, width = 8, height = 5)
# saveRDS(p, here(paste0("./mouse_cortex/plots/lib_size_comparison.rds")))
```

#### By Gene Type

```{r}
# Calculate sums for different gene types
gene_sum_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce = sce_ls[[i]]
  
  lib_size_tb = colData(sce) %>%
    as_tibble() %>%
    mutate(cell_barcode = colnames(sce))
  
  for(gene_type_name in unique(rowData(sce)$gene_type)){ 
    genes_in_type = rowData(sce)[rowData(sce)$gene_type == gene_type_name, "gene_id"]
    m = counts(sce)[genes_in_type, ]
    if(length(genes_in_type) > 1){
      lib_size_gene_type = colSums(m)
    } else {
      lib_size_gene_type = m
    }
    lib_size_tb = lib_size_tb %>% 
      mutate(!!gene_type_name := lib_size_gene_type)
  }
  gene_sum_tb_ls[[pipeline_name]] = lib_size_tb %>%
    mutate(pipeline = pipeline_name)
}
gene_sum_tb = bind_rows(gene_sum_tb_ls)
```

```{r}
# Plot
for(gene_type in c("protein_coding", "lincRNA", "antisense", "processed_pseudogene")){ # 4 with highest counts across all pipelines
  # Compute median label
  summ = gene_sum_tb %>%
    group_by(pipeline, cortex) %>%
    summarize(median = median(!!sym(gene_type)))
  
  p = gene_sum_tb %>%
    ggplot(aes(x = pipeline, y = !!sym(gene_type))) + 
    geom_boxplot() +
    # geom_label(data = summ, aes(x = pipeline, y = median, 
    #                             label = round(median, 0))) +
    labs(x = "Pipeline") +
    facet_wrap(~ cortex) +
    theme_bw()
  
  print(p)
}
```

```{r}
# pipeline = "preandmrna"
# sce = sce_ls[[pipeline]]
```

#### Binned by Overall Expression

```{r}
genes_rowsums_tb = tibble(gene = rownames(sce_ls[["transcripts"]]))
common_cells = Reduce(intersect, sapply(sce_ls, colnames)) # Cell names are different in every pipeline?
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce = sce_ls[[i]]
  m = counts(sce)
  genes_rowsums = rowSums(m)
  tmp_tb = tibble(gene = names(genes_rowsums),
                  !!pipeline_name := genes_rowsums)
  genes_rowsums_tb = genes_rowsums_tb %>%
    left_join(., tmp_tb, by = "gene")
}

# Calculate overall expression and increase
genes_rowsums_tb = genes_rowsums_tb %>%
  mutate(mean_exp = rowMeans(select(genes_rowsums_tb, c("transcripts", "preandmrna", "introncollapse", "intronseparate")), na.rm = T),
         preandmrna_percent_inc = (preandmrna - transcripts)/transcripts)

# Median % increase in each bin
genes_rowsums_tb = genes_rowsums_tb %>%
  mutate(bin = ntile(mean_exp, 10))
genes_rowsums_tb %>%
  group_by(bin) %>%
  summarize(preandmrna_percent_inc_median = median(preandmrna_percent_inc, na.rm = T))

genes_rowsums_tb %>%
  ggplot(aes(x = as.factor(bin), y = preandmrna_percent_inc)) + 
  geom_boxplot() +
  scale_y_log10() +
  theme_bw()
```


#### Binned by GC content

```{r}
library(EDASeq)

id = rownames(sce_ls[["transcripts"]])[1]
id = sub("\\..*", "", id)
org = "mmu"
getGeneLengthAndGCContent(id, org, mode=c("biomart"))
getGeneLengthAndGCContent(id, org, mode=c("org.db"))
```


### Gene Length Bias 

#### Overall length bias

This may have an effect on cell type classification (if marker genes have different lengths). For DE, we fix the gene so a constant length bias for all cell groups should not affect the analysis. 

```{r} 
genes_rowsums_tb = tibble(gene = rownames(sce_ls[["transcripts"]]))
common_cells = Reduce(intersect, sapply(sce_ls, colnames)) 
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce = sce_ls[[i]]
  m = counts(sce)
  genes_rowsums = rowSums(m)
  tmp_tb = tibble(gene = names(genes_rowsums),
                  !!pipeline_name := genes_rowsums)
  genes_rowsums_tb = genes_rowsums_tb %>%
    left_join(., tmp_tb, by = "gene")
}

# Calculate % increase
genes_rowsums_tb = genes_rowsums_tb %>%
  mutate(preandmrna_percent_inc = (preandmrna - transcripts)/transcripts)

# Bin by length
genes_length_tb = rowData(sce_ls[["transcripts"]]) %>%
  as_tibble() %>%
  select(start, end, transcript_length) %>%
  mutate(length = end - start,
         gene = rownames(rowData(sce_ls[["transcripts"]]))) %>%
  select(gene, length, transcript_length)

genes_rowsums_tb = genes_rowsums_tb %>%
  left_join(genes_length_tb, by = "gene")
  
# Median % increase in each bin
genes_rowsums_tb = genes_rowsums_tb %>%
  mutate(bin = ntile(length, 10))

genes_rowsums_tb %>%
  group_by(bin) %>%
  summarize(preandmrna_percent_inc_median = median(preandmrna_percent_inc, na.rm = T))

# % Increase in reads
genes_rowsums_tb %>%
  ggplot(aes(x = as.factor(bin), y = preandmrna_percent_inc)) + 
  geom_boxplot() +
  scale_y_log10() +
  labs(x = "Bin (by gene length)") +
  theme_bw()

# Transcripts gene rowsum
genes_rowsums_tb %>%
  filter(!is.na(transcripts) & !is.na(preandmrna)) %>%
  ggplot(aes(x = as.factor(bin), y = transcripts)) + 
  geom_boxplot() +
  scale_y_log10() +
  labs(x = "Bin (by gene length)") +
  theme_bw()

# Preandmrna gene rowsum
genes_rowsums_tb %>%
  filter(!is.na(transcripts) & !is.na(preandmrna)) %>%
  ggplot(aes(x = as.factor(bin), y = preandmrna)) + 
  geom_boxplot() +
  scale_y_log10() +
  labs(x = "Bin (by gene length)") +
  theme_bw()

# Gene length by bin
genes_rowsums_tb %>%
  filter(!is.na(transcripts) & !is.na(preandmrna)) %>%
  ggplot(aes(x = as.factor(bin), y = length)) +
  scale_y_log10() +
  geom_boxplot() +
  theme_bw()
```

Correct gene length bias in preandmrna pipeline to transcripts pipeline.

```{r}
library(mgcv)
# GAM model to correct for gene length bias
model_tb = tibble(gene = genes_rowsums_tb$gene,         # gene names
                  t = log10(genes_rowsums_tb$length),   # gene lengths
                  m1 = genes_rowsums_tb$preandmrna,     # the expression you want to correct (e.g. nucleic expression)
                  m2 = genes_rowsums_tb$transcripts)    # the expected expression (e.g. whole-cell expression)
model_tb = model_tb %>%
  mutate(M = log2(m1/m2)) %>% # calculate log2-fold expression ratio for each gene
  filter(!is.na(M) & !is.infinite(M)) # remove missing or infinite ratios

# Fit GAM model
model = gam(M ~ s(t), family = gaussian(link = "identity"), data = model_tb)
model_tb$fitted = predict(model, newdata = model_tb)

# Calculate gene length corrected expression
model_tb = model_tb %>%
  mutate(m1_corrected = m1/(2^fitted))
```


```{r}
# Plot gene length (x) vs log2-fold ratio (y), along with GAM model fit (line)
model_tb %>%
ggplot(aes(x = t, y = M)) +
  geom_point(size = 0.1, alpha = 0.1) +
  geom_line(aes(y = fitted), color = "blue") +
  labs(x = "Log10(gene length)",
       y = "Log2-fold ratio") +
  theme_bw()
```


```{r}
# Compare gene length bias in original vs corrected vs expected expression
model_tb %>%
  pivot_longer(cols = c("m1", "m1_corrected", "m2")) %>%
  ggplot(aes(x = t, y = value, color = name)) +
  facet_wrap(~ name, nrow = 1) +
  geom_point(size = 0.1, alpha = 0.01) +
  geom_smooth() +
  scale_y_log10() +
  labs(x = "Log10(gene length)",
       y = "Expression") +
  theme_bw()
```

#### By cell type

```{r}
# Get rowsums for every pipeline and cell type group
common_cells = Reduce(intersect, sapply(sce_ls, colnames)) 

ding_cell_types = unique(colData(sce_ls[[1]])$ding_labels)
ding_cell_types = ding_cell_types[!is.na(ding_cell_types)]

for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  tmp_tb_ls = list()
  
  # Subset to cell type
  for(cell_type in ding_cell_types){
    sce = sce_ls[[i]]
    
    cells_ct = colData(sce) %>% 
      as.data.frame() %>% 
      filter(ding_labels == cell_type) %>% 
      rownames()
    cells_ct = intersect(cells_ct, common_cells)
    
    # Subset to cortex
    for(c in c("cortex1", "cortex2")){
      cortex_cells = colData(sce) %>% 
        as.data.frame() %>% 
        filter(cortex == c) %>%
        rownames()
      
      cells = intersect(cells_ct, cortex_cells)
      
      m = counts(sce[, cells])
      genes_rowmeans = rowMeans(m)
      tmp_tb_ls[[paste(cell_type, c)]] = tibble(gene = names(genes_rowmeans),
                                                !!pipeline_name := genes_rowmeans,
                                                cell_type = cell_type,
                                                cortex = c)
    }
  }
  tmp_tb = bind_rows(tmp_tb_ls)
  
  if(i == 1){
    genes_rowmeans_tb = tmp_tb
  } else {
    genes_rowmeans_tb = genes_rowmeans_tb %>%
      left_join(., tmp_tb, by = c("gene", "cell_type", "cortex"))
  }
}

# Bin by length
genes_length_tb = rowData(sce_ls[["transcripts"]]) %>%
  as_tibble() %>%
  select(start, end, transcript_length) %>%
  mutate(length = end - start,
         gene = rownames(rowData(sce_ls[["transcripts"]]))) %>%
  select(gene, length, transcript_length)

genes_rowmeans_tb = genes_rowmeans_tb %>%
  left_join(genes_length_tb, by = "gene")
```

```{r}
# Plot gene length bias by cell type
genes_rowmeans_tb %>%
  mutate(cell_group = case_when(cell_type %in% c("Excitatory neuron", "Inhibitory neuron") ~ 1,
                                cell_type %in% c("Endothelial", "Microglia") ~ 2,
                                TRUE ~ 3)) %>%
  filter(transcripts > 0) %>%
  ggplot(aes(x = transcript_length, y = transcripts, color = cell_type)) +
  facet_wrap(cortex ~ cell_group, labeller = label_both) +
  geom_point(alpha = 0.01) +
  geom_smooth() + 
  scale_x_log10() +
  scale_y_log10() +
  # scale_y_continuous(limits = c(0, 10)) +
  theme_bw()
```

#### By marker genes

Do different marker genes have different lengths?

```{r}
pred_celltypes = readRDS(here("mouse_cortex", "salmon_quants", "transcripts_pipeline", "singler_results.rds"))
all.markers <- metadata(pred_celltypes)$de.genes

# Subset to singleR labels that appear in (transcripts pipeline) data
celltype_markers = all.markers[unique(colData(sce_ls[[1]])$singleR_labels_pruned)]
celltype_markers = sapply(celltype_markers, unlist)
celltype_markers_tb_ls = list()
for(i in seq_along(celltype_markers)){
  if(is.null(unlist(celltype_markers[i]))) next
  celltype_markers_tb_ls[[i]] = tibble(cell_type = names(celltype_markers)[i],
                               gene_name = unique(unlist(celltype_markers[i])))
}
celltype_markers_tb = bind_rows(celltype_markers_tb_ls) 

celltype_markers_length_tb = rowData(sce_ls[["transcripts"]]) %>%
  as_tibble() %>%
  select(gene_name, start, end, transcript_length) %>%
  mutate(length = end - start,
         gene = rownames(rowData(sce_ls[["transcripts"]]))) %>%
  select(gene, gene_name, length, transcript_length) %>%
  right_join(., celltype_markers_tb, by = "gene_name")

# Plot gene length of marker genes by cell type
celltype_markers_length_tb %>%
  ggplot(aes(x = cell_type, y = length)) + 
  geom_boxplot() + 
  scale_y_log10() +
  coord_flip() +
  theme_bw()

celltype_markers_length_tb %>%
  ggplot(aes(x = cell_type, y = transcript_length)) + 
  geom_boxplot() + 
  scale_y_log10() +
  coord_flip() +
  theme_bw()
```


### PCA

PCA done in `save-sce.R`. To generate and save these plots, run `distribution-plots.R`.

```{r}
# PCA colored by provided attribute
plotReducedDim(sce_ls[["preandmrna"]], "PCA", colour_by = "singleR_labels_pruned", point_size = 1)
```

### HVG

https://osca.bioconductor.org/feature-selection.html

```{r fig.width=5, fig.height=5}
hvg_tb = tibble(gene = rownames(sce_ls[["transcripts"]]))

# Transcripts
for(i in seq_along(sce_ls)){
  pipeline = names(sce_ls)[i]
  sce = sce_ls[[i]]
  
  dec_mgv <- modelGeneVar(sce)
  
  # Visualizing the fit
  fit_mgv <- metadata(dec_mgv)
  # plot(fit_mgv$mean, fit_mgv$var, xlab="Mean of log-expression",
  #      ylab="Variance of log-expression")
  # curve(fit_mgv$trend(x), col="dodgerblue", add=TRUE, lwd=2)
  
  # Get list of HVGs
  tmp_tb = tibble(gene = rownames(dec_mgv),
                  !!pipeline := dec_mgv$p.value)
  
  hvg_tb = hvg_tb %>%
    left_join(., tmp_tb, by = "gene")
}


hvg_tb %>%
  # filter(transcripts < 0.5) %>%
  ggplot(aes(x = transcripts, y = preandmrna)) +
  geom_point(alpha = 0.5) +
  theme_bw() 
```

### Cell types 

Cell types added in `save-sce.R`.

#### singleR

Use singleR to map cells to cell type based on correlation in expression to mouse bulk RNA-seq data.

Vignettes:

* https://www.bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html
* https://bioconductor.org/packages/devel/data/experiment/vignettes/celldex/inst/doc/userguide.html#23_Mouse_RNA-seq

```{r}
library(pheatmap)

pred_celltypes = readRDS(here("mouse_cortex", "salmon_quants", "transcripts_pipeline", "singler_results.rds"))
all.markers <- metadata(pred_celltypes)$de.genes
# Built-in plots
# plotScoreHeatmap(pred_celltypes)
# features = unique(unlist(all.markers$qNSCs))
# features = tx2gene %>% filter(gene_name %in% features) %>% pull(gene_id) %>% unique()
# plotHeatmap(sce[, which(colData(sce)$ding_labels == "Astrocyte")], # Need to run ding section first
#             order_columns_by = "singleR_labels_pruned",
#             features = features,
#             fontsize_row = 1) # takes a while to run if too many cells/genes
```

```{r}
# PCA colored by singleR labels
plotReducedDim(sce, "PCA", colour_by = "singleR_labels_pruned")
```


#### Ding

> We used marker genes for each cell type to compute a score for each cell and automatically assign cell types to clusters.

Cell types added in `save-sce.R`.

```{r}
# PCA colored by Ding's labels
plotReducedDim(sce_ls[["preandmrna"]], "PCA", colour_by = "ding_labels")
```

#### Differences between pipelines

Some of these plots can be generated and saved by running `celltype-plots.R`. 

```{r}
# Get overlap with singleR labels
tb = as_tibble(colData(sce_ls[["preandmrna"]]))
overlap = table(tb$singleR_labels_pruned, tb$ding_labels, useNA = "ifany") %>%
  as.data.frame()

# Normalize frequency within each Ding cell type
overlap = overlap %>%
  group_by(Var2) %>%
  mutate(Freq_norm = Freq/sum(Freq)) %>%
  ungroup()

# Plot
overlap %>%
  ggplot(aes(x = Var1, y = Var2, fill = Freq)) + 
  scale_fill_gradient(low="white", high="blue") +
  geom_tile() +
  labs(x = "singleR_labels_pruned",
       y = "ding_labels") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

overlap %>%
  ggplot(aes(x = Var1, y = Var2, fill = Freq_norm)) + 
  scale_fill_gradient(low="white", high="blue") +
  geom_tile() +
  labs(x = "singleR_labels_pruned",
       y = "ding_labels") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

```{r}
tb = as_tibble(preandmrna_cd) %>%
  mutate(cell = rownames(preandmrna_cd))

# Label cells where singleR label != ding label
tb = tb %>%
  mutate(ding_labels_match = case_when(ding_labels == "Astrocyte" ~ "Astrocytes",
                                       ding_labels == "Endothelial" ~ "Endothelial cells",
                                       ding_labels == "Excitatory neuron" ~ "Neurons",
                                       ding_labels == "Inhibitory neuron" ~ "Neurons",
                                       ding_labels == "Oligodendrocyte" ~ "Oligodendrocytes",
                                       T ~ ding_labels))

tb = tb %>%
  mutate(singleR_labels_match = case_when(singleR_labels_pruned == "Astrocytes activated" ~ "Astrocytes",
                                          singleR_labels_pruned == "Fibroblasts activated" ~ "Fibroblasts",
                                          singleR_labels_pruned == "Fibroblasts senescent" ~ "Fibroblasts",
                                          singleR_labels_pruned == "Macrophages activated" ~ "Macrophages",
                                          singleR_labels_pruned == "Microglia activated" ~ "Microglia",
                                          singleR_labels_pruned == "Neurons activated" ~ "Neurons",
                                          T ~ singleR_labels_pruned),
         non_matching_cells = (singleR_labels_match != ding_labels_match) | (is.na(singleR_labels_match) & !is.na(ding_labels_match)))

tb_misclassify = tb %>%
  filter(!is.na(ding_labels_match)) 

tb_misclassify %>%
  ggplot(aes(x = lib_size)) +
  geom_histogram(aes(fill = non_matching_cells)) +
  facet_wrap(~ ding_labels_match, nrow = 2, scales = "free") +
  labs(title = "preandmrna pipeline") +
  theme_bw()

print(sum(tb_misclassify$non_matching_cells, na.rm = T))

tb_misclassify
```

```{r}
# Counts for marker genes
astrocyte_mg = unique(unlist(all.markers$Astrocytes))
genes_in_type = t2g %>% filter(gene_name %in% astrocyte_mg) %>% pull(gene_id)
cd = colData(sce) %>% as_tibble() %>% mutate(cell = rownames(colData(sce)))
astrocyte_cells = cd %>% filter(ding_labels == "Astrocyte") %>% pull(cell)
astrocyte_matrix = counts(sce)[genes_in_type, astrocyte_cells] # Astrocyte cells and astrocyte marker genes only
# rowSums(astrocyte_matrix)
colSums(astrocyte_matrix) %>% 
  as_tibble() %>%
  mutate(cell = colnames(astrocyte_matrix)) %>%
  left_join(., cd, by = "cell") %>%
  ggplot(aes(x = value)) +
  geom_histogram(aes(fill = singleR_labels_pruned)) +
  theme_bw()
```

```{r}
# genes_in_type = names(sort(-rowSums(astrocyte_matrix))[3]) # Choose a specific gene
gene_type_name = "Astrocyte"
gene_sum_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  
  lib_size_tb = tibble(cell_barcode = astrocyte_cells)
  lib_size_gene_type = colSums(counts(sce_i)[intersect(rownames(counts(sce_i)), genes_in_type), astrocyte_cells, drop = F])
  lib_size_gene_type_tb = tibble(cell_barcode = names(lib_size_gene_type),
                                 !!gene_type_name := lib_size_gene_type)
  lib_size_tb = lib_size_tb %>% 
    left_join(., lib_size_gene_type_tb, by = "cell_barcode")
  gene_sum_tb_ls[[pipeline_name]] = lib_size_tb %>%
    pivot_longer(cols = -cell_barcode) %>%
    mutate(pipeline = pipeline_name)
}
gene_sum_tb = bind_rows(gene_sum_tb_ls)
gene_sum_tb = gene_sum_tb %>%
  pivot_wider(names_from = pipeline, values_from = value)
```

```{r}
# Plot comparison of marker genes for cell type across pipelines
gene_sum_tb %>%
  ggplot(aes(x = transcripts, y = preandmrna)) + 
  geom_point(size = 0.1, alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~ name, scales = "free") +
  labs(x = "num_reads_transcripts",
       y = "num_reads_preandmrna") +
  theme_bw()

# Boxplot
gene_sum_tb_2 = gene_sum_tb %>%
  pivot_longer(-c("cell_barcode", "name"), names_to = "pipeline", values_to = "counts")
summ <- gene_sum_tb_2 %>% 
  group_by(pipeline) %>% 
  summarize(median = median(counts))
gene_sum_tb_2 %>%
  ggplot(aes(x = pipeline, y = counts)) +
  geom_boxplot() +
  geom_label(data = summ, aes(x = pipeline, y = median, 
                              label = round(median, 0))) +
  theme_bw() 
```

```{r}
# Plot ratio of astrocyte:qNSC marker genes for astrocyte cells between pipelines
astrocyte_mg = unique(unlist(all.markers$Astrocytes))
astrocyte_genes = t2g %>% filter(gene_name %in% astrocyte_mg) %>% pull(gene_id)
qnsc_mg = unique(unlist(all.markers$qNSCs))
qnsc_genes = t2g %>% filter(gene_name %in% qnsc_mg) %>% pull(gene_id)

gene_type_name = "Astrocyte qNSC ratio"
gene_sum_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  
  lib_size_tb = tibble(cell_barcode = astrocyte_cells)
  lib_size_gene_type_astrocyte = colSums(counts(sce_i)[intersect(rownames(counts(sce_i)), astrocyte_genes), astrocyte_cells, drop = F])
  lib_size_gene_type_qnsc = colSums(counts(sce_i)[intersect(rownames(counts(sce_i)), qnsc_genes), astrocyte_cells, drop = F])
  lib_size_gene_type_tb = tibble(cell_barcode = names(lib_size_gene_type_astrocyte),
                                 !!gene_type_name := lib_size_gene_type_astrocyte/lib_size_gene_type_qnsc)
  lib_size_tb = lib_size_tb %>% 
    left_join(., lib_size_gene_type_tb, by = "cell_barcode")
  gene_sum_tb_ls[[pipeline_name]] = lib_size_tb %>%
    pivot_longer(cols = -cell_barcode) %>%
    mutate(pipeline = pipeline_name)
}
gene_sum_tb = bind_rows(gene_sum_tb_ls)
gene_sum_tb = gene_sum_tb %>%
  pivot_wider(names_from = pipeline, values_from = value)

# Plot comparison of marker genes for cell type across pipelines
gene_sum_tb %>%
  ggplot(aes(x = transcripts, y = preandmrna)) + 
  geom_point(size = 0.1, alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~ name, scales = "free") +
  labs(x = "num_reads_transcripts",
       y = "num_reads_preandmrna") +
  theme_bw()
```

```{r}
# Boxplot comparing ratios across pipelines
gene_sum_tb_2 = gene_sum_tb %>%
  pivot_longer(-c("cell_barcode", "name"), names_to = "pipeline", values_to = "ratio")
summ <- gene_sum_tb_2 %>% 
  left_join(., cd, by = c("cell_barcode" = "cell")) %>%
  group_by(pipeline) %>% 
  summarize(median = median(ratio))
gene_sum_tb_2 %>%
  left_join(., cd, by = c("cell_barcode" = "cell")) %>%
  ggplot(aes(x = pipeline, y = ratio)) +
  geom_boxplot() +
  geom_label(data = summ, aes(x = pipeline, y = median, 
                              label = round(median, 2))) +
  labs() +
  theme_bw() 
```

```{r}
# Boxplot comparing ratios across singleR_labels under a given pipeline
summ <- gene_sum_tb_2 %>% 
  filter(pipeline == !!pipeline) %>%
  left_join(., cd, by = c("cell_barcode" = "cell")) %>%
  group_by(singleR_labels_pruned) %>% 
  summarize(median = median(ratio))
gene_sum_tb_2 %>%
  filter(pipeline == !!pipeline) %>%
  left_join(., cd, by = c("cell_barcode" = "cell")) %>%
  ggplot(aes(x = singleR_labels_pruned, y = ratio)) +
  geom_boxplot() +
  geom_label(data = summ, aes(x = singleR_labels_pruned, y = median, 
                              label = round(median, 2))) +
  labs(title = pipeline,
       y = "Astrocyte:qNSC ratio") +
  theme_bw() 
```


```{r}
# Find genes that are most different between pipelines
gene_diff_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  gene_diff_tb_ls[[i]] = tibble(pipeline = pipeline_name,
                            gene_id = rownames(counts(sce_i)),
                            sum = rowSums(counts(sce_i)))
}

gene_diff_tb = bind_rows(gene_diff_tb_ls) %>%
  pivot_wider(names_from = pipeline, values_from = sum) %>%
  left_join(., t2g %>% select(gene_id, gene_name), by = "gene_id") %>% # Join to gene name
  mutate(diff = (preandmrna - transcripts)/preandmrna) %>%             # Calculate percent increase from transcripts to preandmrna
  arrange(-diff) %>%                                                   # Arrange by difference
  filter(complete.cases(.))                                            # Remove rows with NA (e.g. genes that are not present in all pipelines)


# Markers for all genes
all_marker_genes_tb_ls = list()
for(cell_type in names(all.markers)){
  all_marker_genes_tb_ls[[cell_type]] = tibble(cell_type = cell_type,
                                               gene_name = unique(unlist(all.markers[[cell_type]])))
}
all_marker_genes_tb = bind_rows(all_marker_genes_tb_ls)
gene_diff_plt = gene_diff_tb %>%
  left_join(., all_marker_genes_tb, by = "gene_name") %>%
  filter(complete.cases(.)) %>%     # Remove genes that are not marker genes
  mutate(group = ceiling((1:n())/1000)) # Assign group for every 1000 genes

# Summary statistics (median difference for each group)
gene_diff_plt %>% 
  group_by(group) %>%
  summarize(median_diff = median(diff)) %>%
  ungroup(group) %>%
  ggplot(aes(x = group, y = median_diff)) +
  geom_bar(stat = "identity") +
  scale_x_continuous(breaks = 1:9) +
  theme_bw()
```

```{r fig.height = 10, fig.width = 8}
library(tidytext) # for reorder_within
# Plot distribution of marker genes for each group 
gene_diff_plt %>%
  group_by(cell_type, group) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  ggplot(aes(x = reorder_within(cell_type, -count, group), y = count)) + 
  geom_bar(stat = "identity") +
  facet_wrap(~ group, scales = "free_x", labeller = label_both) +
  labs(x = "Cell type marker genes",
       title = "Distribution of marker genes grouped by difference between pipelines") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


gene_diff_plt %>%
  group_by(cell_type, group) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  ggplot(aes(x = group, y = count)) + 
  geom_bar(stat = "identity") +
  facet_wrap(~ cell_type, scales = "free_x") +
  scale_x_continuous(breaks = 1:9) +
  labs(x = "Cell type marker genes",
       title = "Distribution of marker genes across the groups") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

```{r}
# Plot lib size for different cell types
lib_size_tb = tibble(cell_barcode = colnames(sce_ls[[1]]),
                     ding_labels = colData(sce)$ding_labels)

for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  
  lib_size = colSums(counts(sce_i))
  lib_size_pipeline_tb = tibble(cell_barcode = colnames(sce_i),
                       !!paste0("lib_size_", pipeline_name) := lib_size)
  lib_size_tb = lib_size_tb %>%
    left_join(., lib_size_pipeline_tb, by = "cell_barcode")
}

lib_size_tb %>%
  ggplot(aes(x = lib_size_transcripts, y = lib_size_preandmrna, color = ding_labels), alpha = 0.5) + 
  facet_wrap(~ ding_labels) + 
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  theme_bw()
```

### DE analysis

Here we compare if differential gene analysis differs between pipelines. 

In particular, I will look at the inhibitory neurons versus excitatory neurons and identify genes that are differentially expressed in these two groups.

```{r}
library(DESeq2)
library(apeglm)

sce_sub = sce_ls[["preandmrna"]][, colData(sce_ls[["preandmrna"]])$ding_labels %in% c("Excitatory neuron", "Astrocyte")]

# Store counts and intermediate quantities (dds is a SummarizedExperiment)
dds = DESeqDataSetFromMatrix(countData = ceiling(counts(sce_sub)[, ]), # take integers 
                             colData = colData(sce_sub),
                             design = ~ cortex + ding_labels)

# Compute log2fold change and p-values
tic()
dds = DESeq(dds) # this function estimates size factor, dispersion, then negative binomial GLM fitting and Wald statistics
toc()

res = results(dds)
res

# Shrinkage of LFC
resultsNames(dds)
resLFC = lfcShrink(dds, coef="ding_labels_Excitatory.neuron_vs_Astrocyte", type="apeglm")

# MA plot for shrunken log2 fold change
plotMA(resLFC)

# Add gene length to table
genes_length_tb = rowData(sce_ls[["preandmrna"]]) %>%
  as_tibble() %>%
  select(start, end) %>%
  mutate(length = end - start,
         gene = rownames(rowData(sce_ls[["preandmrna"]]))) %>%
  select(gene, length)

res = res %>%
  as_tibble() %>%
  mutate(gene = rownames(res)) %>%
  left_join(., genes_length_tb, by = "gene")
```


* The adjusted pvalue, `padj`, comes from the "BH" method of the p.adjust() function in the stats package. Sources: https://support.bioconductor.org/p/74097/, https://www.biostars.org/p/325750/ 
* deseq does "independent filtering" to filter out lowly expressed genes before calculating padj


```{r}
pipeline = "preandmrna"
res = readRDS(here(paste0("./mouse_cortex/output/de_ea_", pipeline, ".rds")))

res = res %>%
  left_join(., genes_rowsums_tb, by = "gene") # from binned by overall expression

# Length vs log2fold change
res %>%
  filter(!is.na(preandmrna)) %>%
  ggplot(aes(x = length, y = log2FoldChange)) + 
  geom_point(alpha = 0.05) +
  geom_smooth() +
  scale_x_log10() +
  theme_bw()

# Length vs pvalue
res %>%
  filter(!is.na(preandmrna)) %>%
  ggplot(aes(x = length, y = pvalue)) + 
  geom_point(alpha = 0.05) +
  geom_smooth() +
  scale_x_log10() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_bw()

# Length vs padj
res %>%
  filter(!is.na(preandmrna)) %>%
  ggplot(aes(x = length, y = padj)) + 
  geom_point(alpha = 0.05) +
  geom_smooth() +
  scale_x_log10() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_bw()

# Expression vs log2fold change
res %>%
  ggplot(aes(x = preandmrna, y = log2FoldChange)) + 
  geom_point(alpha = 0.05) +
  geom_smooth() +
  scale_x_log10(limits = c(0.1, 1e7)) +
  theme_bw()

# Mean exp vs pvalue
res %>%
  ggplot(aes(x = preandmrna, y = pvalue)) + 
  geom_point(alpha = 0.05) +
  geom_smooth() +
  scale_x_log10(limits = c(0.1, 1e7)) +
  scale_y_continuous(limits = c(0, 1)) +
  theme_bw()

# Mean exp vs padj
res %>%
  ggplot(aes(x = preandmrna, y = padj)) + 
  geom_point(alpha = 0.05) +
  geom_smooth() +
  scale_x_log10(limits = c(0.1, 1e7)) +
  scale_y_continuous(limits = c(0, 1)) +
  theme_bw()
```


### Distributions

To assess distributions, we want to obtain a homogenous group of cells.

```{r}
source(here("./mouse_cortex/code/distribution-plots-helpers.R"))
```


```{r}
sce = sce_ls[["preandmrna"]]

# Subset to cell type
cell_type = "Inhibitory neuron"
sce_sub = sce[, colData(sce)$ding_labels == cell_type & !is.na(colData(sce)$ding_labels)]
dim(sce_sub)

# Subset to cortex
sce_sub = sce_sub[, colData(sce_sub)$cortex == "cortex1"]
dim(sce_sub)
```

#### Within-group clustering

Rerun PCA within cell type subgroup.

```{r}
# Normalize and take log
# clust = quickCluster(sce_sub)
# sce_sub = computeSumFactors(sce_sub, clusters = clust)
# sce_sub = logNormCounts(sce_sub)

set.seed(1)
tic("approx PCA")
sce_sub = runPCA(sce_sub, exprs_values = "logcounts", ntop = ncol(sce), BSPARAM = RandomParam())
toc()
```

```{r}
# colData(sce_sub)$cortex_flow_cell = paste(colData(sce_sub)$cortex,
#                                          colData(sce_sub)$flow_cell, sep = "_")
colData(sce_sub)$log_lib_size = log(colData(sce_sub)$lib_size)
plotReducedDim(sce_sub, "PCA", colour_by = "cortex", ncomponents = c(1, 2))
```

```{r eval = F}
# K-means clustering
set.seed(1)

# Elbow plot with SSE
sse = c()
for(k in 1:10){
  clust.kmeans <- kmeans(reducedDim(sce_sub, "PCA"), centers = k)
  sse = c(sse, clust.kmeans$tot.withinss)
}
plot(sse)

clust.kmeans <- kmeans(reducedDim(sce_sub, "PCA"), centers = 4)
colData(sce_sub)$labels_kmeans <- factor(clust.kmeans$cluster)
p = plotReducedDim(sce_sub, "PCA", colour_by = "labels_kmeans", ncomponents = c(1, 2))
# saveRDS(p, here("./mouse_cortex/plots/pca_kmeans_preandmnra_inhibitory_neuron_cortex_1.rds"))
```

```{r eval = F}
# Graph-based clustering
g <- buildSNNGraph(sce_sub, k=10, use.dimred = 'PCA')
clust <- igraph::cluster_walktrap(g)$membership

colData(sce_sub)$labels_gb <- factor(clust)
plotReducedDim(sce_sub, "PCA", colour_by="labels_gb")
```

```{r}
# Use findMarkers (t-test) to identify candidate markers for clusters
markers = findMarkers(sce_sub, groups = colData(sce_sub)$labels_kmeans)

chosen = "1" # cluster chosen
interesting = markers[[chosen]]
best.set <- interesting[interesting$Top <= 6,]
logFCs <- getMarkerEffects(best.set)

library(pheatmap)
pheatmap(logFCs, breaks=seq(-5, 5, length.out=101))
```


#### Proportion of zero plots

First, I make all the column sums comparable by downsampling (this is a stochastic transformation as opposed to scaling).

```{r}
# Subset to cluster
i = 1
counts_sub_cluster = counts(sce_sub)
# counts_sub_cluster = counts(sce_sub)[, colData(sce_sub)$labels_kmeans == i] # Subset to k-means cluster
# group into 3 groups by colSums
terciles = quantile(colSums(counts_sub_cluster), c(1/3, 2/3))
terciles
summary(colSums(counts_sub_cluster))
# counts_sub_cluster = counts_sub_cluster[, (colSums(counts_sub_cluster) > terciles[2])]

tic()
counts_sub_cluster_scaled = Down_Sample_Matrix(ceiling(counts_sub_cluster))
toc()
counts_sub_cluster_scaled = counts_sub_cluster_scaled[rowSums(counts_sub_cluster_scaled) != 0, ]
summary(colSums(counts_sub_cluster_scaled))

# Save values for simulation datasets
# nb_size = function(x){
#   estimates = suppressWarnings(fitdistr(x, "negative binomial")$estimate)
#   return(estimates['size'])
# }
# emp_values = list(means = apply(counts_sub_cluster_scaled, 1, mean),
#                   sizes = apply(counts_sub_cluster_scaled, 1, nb_size))
# saveRDS(emp_values, here("./mouse_cortex/output/emp_values.rds"))

# edgeR
emp_values = list(means = apply(counts_sub_cluster_scaled, 1, mean),
                  sizes = 1/edgeR::estimateDisp(counts_sub_cluster_scaled)$tagwise.dispersion)
saveRDS(emp_values, here("./mouse_cortex/output/emp_values_edger.rds"))
```

I compute the average expression for every row (x-axis) $\hat{\mu}_i$ and the empirical $P(X_i=0)$, which is the probability that for a given transcript $i$, the count is 0. 

I then compute what $P(X_i=0)$ would be under the model assumptions of binomial or poisson, using parameters estimated from the data. In particular, for a $Binom(n, p_i)$, $n$ is the median number of total counts of cells and $p_i$ is the proportion of counts that were in gene $i$.

Generate and save for all combinations by running `distribution_plots.R`.

```{r}
# Plot P(X_i = 0) against average expression level
prob_out = plot_prob(counts_sub_cluster_scaled)
p = prob_out$plot +
  labs(title = paste(cell_type, i, sep = " - "))
print(p)
# saveRDS(p, file = here(paste0("./mouse_cortex/plots/prob0_plot_preandmrna_inhibitory_neuron_cortex_1_cluster_", i, ".rds")))
```

#### Mean-variance plots

To generate these plots for all combinations, run `distribution-plots.R`.


```{r}
# Empirical mean and variance
mean_emp = rowMeans(counts_sub_cluster_scaled)
var_emp = genefilter::rowVars(counts_sub_cluster_scaled)

# Binomial
n = round(median(colSums(counts_sub_cluster_scaled)))
emp_props = rowSums(counts_sub_cluster_scaled)/sum(colSums(counts_sub_cluster_scaled))
var_binom = n*emp_props*(1-emp_props)

# Poisson
fit_pois = glmGamPoi::glm_gp(counts_sub_cluster_scaled, design = ~ 1, size_factors = FALSE, 
                             overdispersion = FALSE)
# Negative binomial
# Estimate overall size/dispersion parameter
model = lm(var_emp ~ 1*mean_emp + I(mean_emp^2) + 0, tibble(mean_emp, var_emp))
phi = 1/coef(model)["I(mean_emp^2)"]

# Estimate size/dispersion parameter for every gene
# library(glmGamPoi)
# fit_nb =  glmGamPoi::glm_gp(counts_sub_cluster_scaled, design = ~ 1, size_factors = FALSE, 
#                          overdispersion = TRUE)

# Note: rowMean(fit_pois$Mu) = rowMeans(fit_nb$Mu) = rowMeans(counts)
mean_var_tb = tibble(mean_emp = mean_emp,
                     var_emp = var_emp,
                     binomial = var_binom,
                     poisson = rowMeans(counts_sub_cluster_scaled),
                     nbinomial = mean_emp + mean_emp^2 * 1/phi) %>%
  # var_nb_v2 = mean_emp + mean_emp^2 * fit_nb$overdispersions) %>% 
  tidyr::pivot_longer(cols = -mean_emp, names_to = "model", values_to = "var_value")

# Plot
p = mean_var_tb %>%
  filter(model %in% c("var_emp")) %>%
  ggplot(aes(x = mean_emp, y = var_value)) + 
  geom_point(alpha = 0.3) + 
  geom_line(data = mean_var_tb %>% filter(model %in% c("binomial", "poisson", "nbinomial")),
            aes(x = mean_emp, y = var_value, color = model)) +
  scale_x_log10() + scale_y_log10() +
  labs(title = pipeline,
       subtitle = paste(cell_type, cortex, sep = " - "),
       x = "Log of mean expression",
       y = "Log of variance") +
  theme_bw()
```

#### Goodness-of-fit tests

##### By Count Values

There are 2 issues:

1) Why is quant matrix not all integers?
2) Why are NaNs produced/non-finite finite-difference value errors occur in fitdistr("negative binomial")?

```{r eval = F}
library(MASS)

# Poisson
p_values_pois = p_chisq_test(counts_sub_cluster_scaled, distribution = "poisson")
plot_dt = tibble(p_value = p_values_pois[[1]],
                 expression = rowSums(counts_sub_cluster_scaled))

plot_dt %>%
  # filter(expression > 50) %>%
  ggplot(aes(x = p_value)) + 
  geom_histogram() +
  theme_bw()

plot_dt %>%
  # filter(expression > 50) %>%
  ggplot(aes(x = p_value, y = expression)) + 
  geom_point(size = 0.1, alpha = 0.1) +
  geom_smooth() +
  scale_y_log10() +
  theme_bw()
```

```{r}
# Negative binomial
p_values_nb = p_chisq_test(counts_sub_cluster_scaled, distribution = "nb")
plot_dt = tibble(p_value = p_values_nb[[1]],
                 expression = rowSums(counts_sub_cluster_scaled)[setdiff(1:nrow(counts_sub_cluster_scaled), p_values_nb[[2]])])

plot_dt %>%
  # filter(expression > 50) %>%
  ggplot(aes(x = p_value)) + 
  geom_histogram() +
  theme_bw()

plot_dt %>%
  # filter(expression > 50) %>%
  ggplot(aes(x = p_value, y = expression)) + 
  geom_point(size = 0.1, alpha = 0.1) +
  geom_smooth() +
  scale_y_log10() +
  theme_bw()
```

##### By Sample

This is based on Figure 2 from this paper: https://genome.cshlp.org/content/18/9/1509.full.html 

```{r}
# Poisson
chi_obs_pois = p_chisq_test_2(counts_sub_cluster_scaled, distribution = "poisson")
plot_dt = tibble(chi_obs = chi_obs_pois,
                 expression = rowSums(counts_sub_cluster_scaled)) %>%
  arrange(chi_obs) %>%
  drop_na() %>%
  mutate(chi_quantile = qchisq(p = (1:length(chi_obs))/length(chi_obs), df = ncol(counts_sub_cluster_scaled) - 1),
         percentile_color = case_when(chi_obs > quantile(chi_obs, 0.995) ~ "> 99.5",
                                      chi_obs > quantile(chi_obs, 0.95) ~ "> 95",
                                      chi_obs > quantile(chi_obs, 0.90) ~ "> 90",
                                      T ~ "rest"),
         i = i)

plot_dt %>%
  # filter(expression > 50) %>%
    ggplot(aes(x = chi_quantile,
             y = chi_obs,
             color = percentile_color)) + 
  geom_point(size = 0.5) + 
  geom_abline(slope = 1, intercept = 0) +
  # coord_cartesian(ylim = c(250, 1000)) +
  theme_bw()
```

```{r}
# Negative binomial (single overdispersion parameter)
chi_obs_nb = p_chisq_test_2(counts_sub_cluster_scaled, distribution = "nb 1")
plot_dt = tibble(chi_obs = chi_obs_nb) %>%
  arrange(chi_obs) %>%
  drop_na() %>%
  mutate(chi_quantile = qchisq(p = (1:length(chi_obs))/length(chi_obs), df = ncol(counts_sub_cluster_scaled) - 1),
         percentile_color = case_when(chi_obs > quantile(chi_obs, 0.995) ~ "> 99.5",
                                      chi_obs > quantile(chi_obs, 0.95) ~ "> 95",
                                      chi_obs > quantile(chi_obs, 0.90) ~ "> 90",
                                      T ~ "rest"),
         i = i)

plot_dt %>%
  # filter(expression > 50) %>%
    ggplot(aes(x = chi_quantile,
             y = chi_obs,
             color = percentile_color)) + 
  geom_point(size = 0.5) + 
  geom_abline(slope = 1, intercept = 0) +
  # coord_cartesian(ylim = c(250, 1000)) +
  theme_bw()
```

```{r}
# Negative binomial (gene-specific overdispersion parameter)
chi_obs_nb = p_chisq_test_2(counts_sub_cluster_scaled, distribution = "nb 2")
plot_dt = tibble(chi_obs = chi_obs_nb) %>%
  arrange(chi_obs) %>%
  drop_na() %>%
  mutate(chi_quantile = qchisq(p = (1:length(chi_obs))/length(chi_obs), df = ncol(counts_sub_cluster_scaled) - 1),
         percentile_color = case_when(chi_obs > quantile(chi_obs, 0.995) ~ "> 99.5",
                                      chi_obs > quantile(chi_obs, 0.95) ~ "> 95",
                                      chi_obs > quantile(chi_obs, 0.90) ~ "> 90",
                                      T ~ "rest"),
         i = i)

plot_dt %>%
  # filter(expression > 50) %>%
  ggplot(aes(x = chi_quantile,
             y = chi_obs,
             color = percentile_color)) + 
  geom_point(size = 0.5) + 
  geom_abline(slope = 1, intercept = 0) +
  # coord_cartesian(ylim = c(250, 1000)) +
  theme_bw()
```


##### Likelihood-Ratio

```{r}
library(tweeDEseq)
```

```{r}
x2_lr = gofTest(counts_sub_cluster_scaled, a = 1) # poisson

plot_dt = tibble(chi_obs = sort(x2_lr),
                 chi_quantile = qchisq(p = (1:length(sort(x2_lr)))/length(sort(x2_lr)),
                                       df = 1),
                 percentile_color = case_when(chi_obs > quantile(chi_obs, 0.995) ~ "> 99.5",
                                        chi_obs > quantile(chi_obs, 0.95) ~ "> 95",
                                        chi_obs > quantile(chi_obs, 0.90) ~ "> 90",
                                        T ~ "rest"))

plot_dt %>%
  ggplot(aes(x = chi_quantile,
             y = chi_obs,
             color = percentile_color)) + 
  geom_point(size = 0.5) + 
  geom_abline(slope = 1, intercept = 0) +
  # coord_cartesian(ylim = c(250, 1000)) +
  theme_bw()
```

```{r}
x2_lr = gofTest(counts_sub_cluster_scaled, a = 0) # negative binomial

plot_dt = tibble(chi_obs = sort(x2_lr),
                 chi_quantile = qchisq(p = (1:length(sort(x2_lr)))/length(sort(x2_lr)),
                                       df = 1),
                 percentile_color = case_when(chi_obs > quantile(chi_obs, 0.995) ~ "> 99.5",
                                        chi_obs > quantile(chi_obs, 0.95) ~ "> 95",
                                        chi_obs > quantile(chi_obs, 0.90) ~ "> 90",
                                        T ~ "rest"))

plot_dt %>%
  ggplot(aes(x = chi_quantile,
             y = chi_obs,
             color = percentile_color)) + 
  geom_point(size = 0.5) + 
  geom_abline(slope = 1, intercept = 0) +
  # coord_cartesian(ylim = c(250, 1000)) +
  theme_bw()
```


#### BIC log-likelihood

Source: https://github.com/willtownes/scrna2019/blob/028363f04139a58b19143f3058ca8fa4a3533b63/util/functions.R


```{r eval = F}
m = counts_sub_cluster_scaled
m = ceiling(m)
summary(colSums(m))
summary(rowSums(m))
m = m[rowSums(m) != 0, ]
dim(m)

bic_tb = tibble(multinomial = mult_bic(m),     # 5 sec
                # dmn = dmn_bic(m),     # Unknown time, need to run as script on cluster
                poisson = poi_bic(m),       # 5 sec
                negative_binomial_1 = nb_bic_1(m),     # 5 sec
                negative_binomial_2 = nb_bic_2(m),   # 15 min
                cell_type_name = cell_type)

# Plot
bic_tb %>% 
  pivot_longer(cols = -cell_type_name) %>%
  ggplot(aes(x = reorder(name, value), y = value)) +
  geom_point(size = 3) +
  labs(title = pipeline,
       x = "Distribution",
       y = "BIC") +
  theme_bw()
```

