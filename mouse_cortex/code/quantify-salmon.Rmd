---
title: quantification of mouse cortex data 
author: Stephanie Hicks and Albert Kuo
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{bash}
# Commands to start an interactive session on the JHPCE cluster
ii # alias for qrsh -l mem_free=20G,h_vmem=20G
module load conda_R
cd /fastscratch/myscratch/akuo/alsf-filbin
R
```

# Organize directory

```{r}
library(here)
```

First, we create the folder to store reference files (e.g. genome and cDNA) and quantification files (quantified counts) from salmon.  

```{r}
if(!dir.exists(here("salmon_files"))){
  dir.create(here("salmon_files"))
}
if(!dir.exists(here("salmon_files", "human"))){
  dir.create(here("salmon_files", "human"))
}
if(!dir.exists(here("salmon_files", "mouse"))){
  dir.create(here("salmon_files", "mouse"))
}
if(!dir.exists(here("mouse_cortex", "salmon_quants"))){
  dir.create(here("mouse_cortex", "salmon_quants"))
}
if(!dir.exists(here("mouse_cortex", "log"))){
  dir.create(here("mouse_cortex", "log"))
}
```

# Quantification 

We will do quantification with alevin from Salmon:

## Download files

We need to download 3 files (mouse):

1. `GRCm38.primary_assembly.genome.fa.gz` - nucleotide (DNA) sequences of the **GRCm38 primary genome assembly** (chromosomes and scaffolds -- i.e. unplaced scaffolds?)
2. `gencode.vM25.transcripts.fa.gz` - nucleotide (DNA) sequences of **all transcripts** on reference chromosomes (Note: We are going to extract the transcript sequences using \#1 and \#3, so this will on longer be used.)
3. `gencode.vM25.annotation.gtf.gz` - gene annotation on the reference chromosomes (i.e. for humans, these are chromosomes 1 to 22, X, and Y), i.e. locations of genes and other information about the genes, gene structure
  * Gene transfer format (GTF) is a file format used to hold information about gene structure. It is a tab-delimited text format based on the general feature format (GFF), but contains some additional conventions specific to gene information.

Source: https://www.gencodegenes.org/human/

```{r}
library(here)

# download GENCODE primary assembly fasta file
if(!file.exists(here("salmon_files", "mouse", "GRCm38.primary_assembly.genome.fa.gz"))){
  tar_gz_file <- "ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/GRCm38.primary_assembly.genome.fa.gz"
  download.file(tar_gz_file, 
                destfile = here("salmon_files", "mouse", "GRCm38.primary_assembly.genome.fa.gz"), 
                method = "wget")
}

# download GENCODE transcripts fasta file
if(!file.exists(here("salmon_files", "mouse", "gencode.vM25.transcripts.fa.gz"))){
  tar_gz_file <- "ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.transcripts.fa.gz"
  download.file(tar_gz_file,
                destfile = here("salmon_files", "mouse", "gencode.vM25.transcripts.fa.gz"),
                method = "wget")
}

# download GENCODE gtf file
if(!file.exists(here("salmon_files", "mouse", "gencode.vM25.annotation.gtf.gz"))){
  tar_gz_file <- "ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.annotation.gtf.gz"
  download.file(tar_gz_file, 
                destfile = here("salmon_files", "mouse", "gencode.vM25.annotation.gtf.gz"), 
                method = "wget")
}
```




## mRNA only ("transcripts") pipeline

```{r}
suppressPackageStartupMessages({
  library(here)
  library(dplyr)
  library(Biostrings)
  library(rtracklayer)
  library(GenomicFeatures)
  library(BSgenome)
})
# source(here("scripts", "quantify-salmon-helpers.R")) # cannot find this file in github -- need to ask Albert
```

### FASTA file

For the mRNA only index pipeline, we will build the transcripts FASTA using the transcripts GTF and the whole genome FASTA.

Note: We used to use the downloaded FASTA file from GENCODE. 
However, extracting the FASTA from the whole genome is more consistent with the other pipelines. 
In theory, they should be the same thing.


### tx2gene

We make a transcript-to-gene mapping table from the gtf file. 
This table will serve as the basis for similar tables in the other pipelines.

Source: README in https://github.com/csoneson/rna_velocity_quant

```{r}
suppressPackageStartupMessages({
  library(rtracklayer)
  library(dplyr)
  library(here)
})

# Read gtf
gtf <- rtracklayer::import(here("mouse_cortex", "salmon_files",
                                "gencode.vM25.annotation.gtf.gz")) 
gtftx <- subset(gtf, type == "transcript")
gtfex <- subset(gtf, type == "exon")

df <- data.frame(gtftx, stringsAsFactors = FALSE) %>%
  dplyr::select(transcript_id, seqnames, start, end, strand, source, 
                gene_id, gene_type, gene_name, level, havana_gene, transcript_type,
                transcript_name, transcript_support_level, tag, havana_transcript) %>%
  dplyr::left_join(data.frame(gtfex, stringsAsFactors = FALSE) %>%
                     dplyr::group_by(transcript_id) %>% 
                     dplyr::summarize(transcript_length = sum(width)),
                   by = "transcript_id")

# Write table as txt and rds
write.table(df %>% dplyr::select(transcript_id, gene_id), 
            file = here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.tx2gene.mouse.txt"), 
            sep = "\t", quote = FALSE, row.names = FALSE, 
            col.names = FALSE)
saveRDS(df, file = here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.tx2gene.mouse.rds"))
```

### decoys (only for Salmon)

The decoy sequence is going to be the whole genome sequence (`GRCm38.primary_assembly.genome.fa.gz`) for all 3 pipelines. You can read more about decoy sequences in Salmon below:

* https://salmon.readthedocs.io/en/latest/salmon.html#preparing-transcriptome-indices-mapping-based-mode
* https://github.com/COMBINE-lab/SalmonTools/blob/master/README.md

Source for code: https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/

To use a decoy, we need to create two files:

1. `decoys.txt` is the names of the genome targets (decoys), will be used in the `-d` parameter in `build-index-salmon.sh`
2. `gentrome_transcripts.fa.gz` is a concatenated FASTA transcriptome, will be used in the `-t` parameter in `build-index-salmon.sh`. Note that you need to recreate this in every pipeline.

```{bash}
# 1. Salmon indexing requires the names of the genome targets, which is extractable by using the grep command:
grep "^>" <(gunzip -c GRCm38.primary_assembly.genome.fa.gz) | cut -d " " -f 1 > decoys.txt
sed -i.bak -e 's/>//g' decoys.txt
```

```{bash}
# 2. Along with the list of decoys salmon also needs the concatenated transcriptome and genome reference file for index. NOTE: the genome targets (decoys) should come after the transcriptome targets in the reference
cat gencode.vM25.transcripts.fa.gz GRCm38.primary_assembly.genome.fa.gz > gentrome_transcripts_mouse.fa.gz
```

## mRNA and pre-mRNA ("preandmrna") pipeline

For the mRNA and pre-mRNA pipeline, we will build an index with both mRNA and pre-mRNA sequences. 

Source: generate_spliced_unspliced_fa.R in https://github.com/csoneson/rna_velocity_quant/.

```{r}
suppressPackageStartupMessages({
  library(here)
  library(dplyr)
  library(Biostrings)
  library(rtracklayer)
  library(GenomicFeatures)
  library(BSgenome)
})
source(here("mouse_cortex", "code", "quantify-salmon-helpers.R"))
```

### FASTA file 

We make a combined FASTA file with both mRNA and pre-mRNA sequences (`gencode.vM25.preandmrna.fa`).

```{r}
# Gtf path
gtf_file <- here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.gtf.gz")

# Read genomic (DNA) sequence from FASTA file
genome_fasta <- here("mouse_cortex", "salmon_files", "GRCm38.primary_assembly.genome.fa.gz") 
genome <- Biostrings::readDNAStringSet(genome_fasta)
names(genome) <- sapply(strsplit(names(genome), " "), .subset, 1) # creates chr1, etc

# Extract transcript (tx) and pre-mRNA (premrna) sequences (takes a few minutes)
tx <- extractTxSeqs(gtf = gtf_file, genome = genome, type = "spliced")
premrna <- extractTxSeqs(gtf = gtf_file, genome = genome, type = "unspliced")
names(premrna) <- paste0(names(premrna), "_unspliced")

# Combine mRNA and pre-mRNA sequences
preandmrna <- c(tx, premrna)

# Write FASTA file
Biostrings::writeXStringSet(preandmrna, file = here("mouse_cortex", "salmon_files", "gencode.vM25.preandmrna.mouse.fa.gz"), compress = T) # Compresses fa while saving, rather than compress later
```

### tx2gene

```{r}
# Generate tx2gene table for mRNA and pre-mRNA transcripts
t2g <- readRDS(here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.tx2gene.mouse.rds"))
t2gpre <- t2g %>% dplyr::mutate(transcript_id = paste0(transcript_id, "_unspliced"))
t2g <- rbind(t2g, t2gpre)

# Write table as txt
write.table(t2g %>% dplyr::select(transcript_id, gene_id), 
            file = here("mouse_cortex", "salmon_files", "gencode.vM25.preandmrna.tx2gene.mouse.txt"), 
            row.names = FALSE, col.names = FALSE, 
            sep = "\t", quote = FALSE)
```

### decoys

1. `decoys.txt` was already generated in the mRNA only pipeline

2. `gentrome_preandmrna.fa.gz` is a concatenated FASTA transcriptome, will be used in the `-t` parameter in `build-index-salmon.sh`

```{bash}
# The genome targets (decoys) should come after the transcriptome targets in the reference
cat gencode.vM25.preandmrna.mouse.fa.gz GRCm38.primary_assembly.genome.fa.gz > gentrome_preandmrna_mouse.fa.gz
```

## mRNA and intron ("introncollapse" or "intronseparate") pipeline

For the mRNA and intron pipeline, we will build an index with both mRNA and intron sequences. 

Source: generate_cdna_intron_fa_prepref.R in https://github.com/csoneson/rna_velocity_quant/.

```{r}
suppressPackageStartupMessages({
  library(here)
  library(dplyr)
  library(Biostrings)
  library(rtracklayer)
  library(GenomicFeatures)
  library(BSgenome)
})
source(here("mouse_cortex", "code", "quantify-salmon-helpers.R"))
```

### FASTA file 

We make a combined FASTA file with both mRNA and intron sequences (`gencode.vM25.introncollapse.fa`).

```{r}
# Gtf path
gtf_file <- here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.gtf.gz")

# Read genomic (DNA) sequence from FASTA file
genome_fasta <- here("mouse_cortex", "salmon_files", "GRCm38.primary_assembly.genome.fa.gz") 
genome <- Biostrings::readDNAStringSet(genome_fasta)
names(genome) <- sapply(strsplit(names(genome), " "), .subset, 1) # creates chr1, etc

# Extract transcript (tx) and intron sequences (takes a few minutes)
tx <- extractTxSeqs(gtf = gtf_file, genome = genome, type = "spliced")
isoform_action = "separate"
flanklength = 90 # default in script
intr <- extractIntronSeqs(gtf = gtf_file, genome = genome, type = isoform_action, 
                          flanklength = flanklength,
                          joinOverlappingIntrons = FALSE)

# Combine mRNA and pre-mRNA sequences
intronandmrna <- c(tx, intr)

# Write FASTA file
Biostrings::writeXStringSet(intronandmrna, file = here("mouse_cortex", "salmon_files",
                                                       paste0("gencode.vM25.intron", isoform_action, ".mouse.fa.gz")), compress = TRUE)
```

### tx2gene

Source: generate_cdna_intron_fa_prepref.R in https://github.com/csoneson/rna_velocity_quant/.

```{r}
suppressPackageStartupMessages({
  library(rtracklayer)
  library(dplyr)
  library(here)
})

# Generate transcript/intron-to-gene mapping
gtfdf <- as.data.frame(rtracklayer::import(here("mouse_cortex", "salmon_files",
                                "gencode.vM25.annotation.gtf.gz")))
t2gtx <- gtfdf %>% dplyr::filter(type == "transcript") %>%
  dplyr::select(transcript_id, gene_id) %>%
  dplyr::distinct()

if (isoform_action == "collapse") {
  ## Intron names already contain gene name
  t2gin <- data.frame(intr = names(intr),
                      gene = gsub("\\-I[0-9]*$", "", names(intr)),
                      stringsAsFactors = FALSE)
} else if (isoform_action == "separate") {
  ## Intron names contain transcript name
  t2gin <- data.frame(intr = names(intr),
                      transcript_id = gsub("\\-I[0-9]*$", "", names(intr)),
                      stringsAsFactors = FALSE) %>%
    dplyr::left_join(t2gtx, by = "transcript_id") %>%
    dplyr::select(intr, gene_id)
} else {
  stop("Unknown isoform_action")
}
colnames(t2gin) <- colnames(t2gtx)
t2g <- rbind(t2gtx, t2gin)

# Write table as txt
write.table(t2g, file = here("mouse_cortex", "salmon_files", paste0("gencode.vM25.intron", isoform_action, ".tx2gene.mouse.txt")), 
            row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")
```

### decoys

1. `decoys.txt` was already generated in the mRNA only pipeline

2. `gentrome_introncollapse.fa.gz` is a concatenated FASTA transcriptome, will be used in the `-t` parameter in `build-index-salmon.sh`

```{bash}
# The genome targets (decoys) should come after the transcriptome targets in the reference
cat gencode.vM25.introncollapse.mouse.fa.gz GRCm38.primary_assembly.genome.fa.gz > gentrome_introncollapse_mouse.fa.gz
cat gencode.vM25.intronseparate.mouse.fa.gz GRCm38.primary_assembly.genome.fa.gz > gentrome_intronseparate_mouse.fa.gz
```

## Run salmon alevin

### Install and build salmon index 

This part will have to be done for each user. 
I installed the salmon 1.2.1 binary in my home directory here `/users/shicks1/src/`. 

To install salmon v1.2.1: 
```{bash}
cd /users/shicks1/src/

wget https://github.com/COMBINE-lab/salmon/releases/download/v1.2.1/salmon-1.2.1_linux_x86_64.tar.gz
tar xzvf salmon-1.2.1_linux_x86_64.tar.gz
rm salmon-1.2.1_linux_x86_64.tar.gz
```

Also, make sure this is in the `.bash_profile` file
```{bash}
PATH=$PATH:/users/shicks1/src/salmon-latest_linux_x86_64/bin
```

You can check to make sure salmon has been upgraded correctly using `salmon -h` inside terminal (or help with specific parts of using salmon using e.g. `salmon index -h` for help with the index step). 

OK, we are ready to use salmon. 
The `-t` argument is the input transcripts file. 
The `-i` argument is the index file to create. 
The `-d` argument is the decoy sequence. 
The `--keepDuplicates` argument forces all duplicate transcripts (for example, multiple unspliced transcript of the same gene that are identical for example) that appear in the input will be retained and quantified separately. 
If you keep the duplicates they will be assigned identical expression levels since salmon canâ€™t tell them apart. 
When you aggregate on the gene level, this will not make a difference any more. 
Therefore, I do not keep the duplicates as we are interested in gene level aggregation. 
The `--gencode` flag will handle the composite fasta headers in GENCODE transcript fasta files and split the transcript name at the first '|' character. 
The `--threads` argument says how many threads to use when building the index. 

There is a script `build-index-salmon.sh` in the `/mouse_cortex` folder that was used to run this code with 4 cores. The index is built from the combined FASTA file.

### Quantification with salmon alevin

We will now use the index created by `build-index-salmon.sh`.
See the `mouse_cortex/code/run-alevin.sh` file.

### Set up the tximeta package 

Next, we use the `tximeta` package to create a SummarizedExperiment object.
If we try to run `tximeta(coldata)`, that will fail because `tximeta` won't be able to detect automatically what the reference transcriptome is. 
So, here we create our own [linked transcriptome](https://bioconductor.org/packages/release/bioc/vignettes/tximeta/inst/doc/tximeta.html#linked_transcriptomes) from the combined GTF file.
This step is not necessary if your index was only the mRNA transcripts.

A `linkedTxome` records key information about the sources of the transcript FASTA files, and the location of the relevant GTF file. 
It also records the checksum of the transcriptome that was computed by Salmon during the index step.

```{r}
suppressPackageStartupMessages({
  library(tximeta)
})

# create linkedTranscriptome for mRNA (only) decoys pipeline
index_dir = here("mouse_cortex", "salmon_files", "gencode.vM25_salmon-index-v1.0.0-transcripts-mouse")
fasta_path = here("mouse_cortex", "salmon_files", "gencode.vM25.transcripts.mouse.fa.gz")
gtf_path = here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.gtf.gz") 
json_file = here("mouse_cortex", "salmon_files", paste0(basename(index_dir), ".json"))
makeLinkedTxome(indexDir=index_dir,
                source="other", organism="mouse",
                release="other", genome="GRCm38",
                fasta=fasta_path, gtf=gtf_path,
                jsonFile=json_file) # this command will add the index to the cache automatically

# created linkedTranscriptome for preandmrna decoys pipline
index_dir = here("mouse_cortex", "salmon_files", "gencode.vM25_salmon-index-v1.0.0-preandmrna-mouse")
fasta_path = here("mouse_cortex", "salmon_files", "gencode.vM25.preandmrna.mouse.fa.gz")
gtf_path = here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.gtf.gz") 
json_file = here("mouse_cortex", "salmon_files", paste0(basename(index_dir), ".json"))
makeLinkedTxome(indexDir=index_dir,
                source="other", organism="mouse",
                release="other", genome="GRCm38",
                fasta=fasta_path, gtf=gtf_path,
                jsonFile=json_file) # this command will add the index to the cache automatically

# created linkedTranscriptome for introncollapse decoys pipline
index_dir = here("mouse_cortex", "salmon_files", "gencode.vM25_salmon-index-v1.0.0-introncollapse-mouse")
fasta_path = here("mouse_cortex", "salmon_files", "gencode.vM25.introncollapse.mouse.fa.gz")
gtf_path = here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.gtf.gz") 
json_file = here("mouse_cortex", "salmon_files", paste0(basename(index_dir), ".json"))
makeLinkedTxome(indexDir=index_dir,
                source="other", organism="mouse",
                release="other", genome="GRCm38",
                fasta=fasta_path, gtf=gtf_path,
                jsonFile=json_file) # this command will add the index to the cache automatically
```


## Create SummarizedExperiment object

```{r eval = F}
suppressPackageStartupMessages({
  library(here)
  library(tximeta)
  library(BiocFileCache)
  library(SummarizedExperiment)
})

# check if linkedTxome is already in the cache
bfcloc <- getTximetaBFC()
bfc <- BiocFileCache(bfcloc)
bfcinfo(bfc)

# if not, load linkedTxome json file
# json_file <- here("salmon_files", "mouse", "salmon_index_gentrome_decoys_k25.json")
json_file = here("mouse_cortex", "salmon_files", "gencode.v32_salmon-index-v1.0.0-preandmrna-mouse")
loadLinkedTxome(json_file)
```


```{r eval = F}
# Note: alevin import currently only supports a single experiment
pipeline = "introncollapse" # "transcripts" or "preandmrna" or "introncollapse/separate"
run_names = gsub("_quant", "", basename(list.dirs(here("mouse_cortex", "salmon_quants", paste0(pipeline, "_pipeline")), recursive = F)))
run_names = run_names[!grepl("nodecoys", run_names)]
file_paths = here("mouse_cortex", "salmon_quants", paste0(pipeline, "_pipeline"), paste0(run_names, "_quant"), "alevin", "quants_mat.gz") 

i = 1
se = tximeta(coldata = data.frame(names = run_names[i],
                                  files = file_paths[i],
                                  stringsAsFactors = FALSE),
             type = "alevin")

# Check SummarizedExperiment object
colData(se)
assayNames(se)
rowRanges(se)

# Save SummarizedExperiment object
saveRDS(se, here("mouse_cortex", "salmon_quants", paste0("se_", run_names[i], "_", pipeline, ".rds")))
```

## Exploratory Analysis

```{r}
suppressPackageStartupMessages({
  library(here)
  library(tidyverse)
  library(tictoc)
  library(scran)
  library(scater)
  library(BiocSingular)
})
se_ls = list()
se_ls[["transcripts"]] = readRDS(here("mouse_cortex", "salmon_quants", "se_SRR9169228_transcripts.rds"))
se_ls[["preandmrna"]] = readRDS(here("mouse_cortex", "salmon_quants", "se_SRR9169228_preandmrna.rds"))
se_ls[["introncollapse"]] = readRDS(here("mouse_cortex", "salmon_quants", "se_SRR9169228_introncollapse.rds"))
```

### Quality control

```{r fig.width = 5, fig.height = 5}
sce_ls = list()
for(i in seq_along(se_ls)){
  se = se_ls[[i]]
  # Remove empty rows
  non_empty_rows <- which(rowSums(assay(se, "counts")) > 1)
  se_subset <- se[non_empty_rows, ]
  
  # Remove low-quality cells
  df = perCellQCMetrics(se_subset)
  reasons = quickPerCellQC(df) # DataFrame of logical values
  colSums(as.matrix(reasons))
  
  # Convert to SingleCellExperiment
  sce = as(se_subset[, !reasons$discard], "SingleCellExperiment")
  colData(sce)$lib_size = colSums(counts(sce))
  sce_ls[[names(se_ls)[i]]] = sce
}

# Plot library sizes
lib_sizes = lapply(X = sce_ls, function(x) colData(x) %>% as_tibble() %>% mutate(cell_barcode = rownames(colData(x))))
inner_join(lib_sizes$transcripts, lib_sizes$preandmrna, by = "cell_barcode") %>%
  ggplot(aes(x = lib_size.x, y = lib_size.y)) + 
  geom_point(size = 0.5, alpha = 0.5) + 
  geom_abline(intercept = 0, slope = 1) +
  labs(x = "num_reads_transcripts", y = "num_reads_preandmrna") +
  theme_bw()

lib_sizes_tb = lib_sizes %>%
  purrr::reduce(inner_join, by = "cell_barcode") %>%
  dplyr::rename(preandmrna = lib_size.y,
                transcripts = lib_size.x,
                introncollapse = lib_size) %>%
  pivot_longer(cols = c("preandmrna", "transcripts", "introncollapse"), names_to = "pipeline")

summ <- lib_sizes_tb %>% 
  group_by(pipeline) %>% 
  summarize(median = median(value))

lib_sizes_tb %>%
  ggplot(aes(x = pipeline, y = value)) +
  geom_boxplot() + 
  geom_label(data = summ, aes(x = pipeline, y = median, 
                              label = round(median, 0))) +
  labs(y = "num_reads") +
  theme_bw()
```

### Mapping differences by gene

We investigate the differences in mapping rate

```{r}
# Read in gene metadata
tx2gene = readRDS(here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.tx2gene.mouse.rds"))

for(i in seq_along(sce_ls)){
  match_rows = match(rownames(sce_ls[[i]]), tx2gene$gene_id)
  t2g = tx2gene[match_rows, ]
  rowData(sce_ls[[i]]) = t2g
}
```

```{r}
# Calculate sums for different gene types
gene_sum_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce = sce_ls[[i]]
  
  lib_size_tb = tibble(cell_barcode = colnames(sce))
  for(gene_type_name in c("protein_coding", "lincRNA", "antisense", "processed_pseudogene")){
    genes_in_type = rowData(sce) %>% as_tibble() %>% filter(gene_type == gene_type_name) %>% pull(gene_id)
    lib_size_gene_type = colSums(counts(sce)[genes_in_type,])
    lib_size_gene_type_tb = tibble(cell_barcode = names(lib_size_gene_type),
                                   !!gene_type_name := lib_size_gene_type)
    lib_size_tb = lib_size_tb %>% 
      left_join(., lib_size_gene_type_tb, by = "cell_barcode")
  }
  gene_sum_tb_ls[[pipeline_name]] = lib_size_tb %>%
    pivot_longer(cols = -cell_barcode) %>%
    mutate(pipeline = pipeline_name)
}
gene_sum_tb = bind_rows(gene_sum_tb_ls)
gene_sum_tb = gene_sum_tb %>%
  pivot_wider(names_from = pipeline, values_from = value)
```

```{r}
# Plot
gene_sum_tb %>%
  ggplot(aes(x = introncollapse, y = preandmrna)) + 
  geom_point(size = 0.1, alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~ name, scales = "free") +
  labs(x = "num_reads_introncollapse",
       y = "num_reads_preandmrna") +
  theme_bw()
```

```{r}
sce = sce_ls[["transcripts"]]
```

### PCA

```{r}
# Normalize and take log
clust = quickCluster(sce)
sce = computeSumFactors(sce, clusters = clust)
sce = logNormCounts(sce)

set.seed(1)
tic("approx PCA")
sce = runPCA(sce, exprs_values = "logcounts", ntop = ncol(sce), BSPARAM = RandomParam())
toc()

# PCA colored by library size
plotReducedDim(sce, "PCA", colour_by = "lib_size")
```

### Cell types 

#### singleR

Use singleR to map cells to cell type based on correlation in expression to mouse bulk RNA-seq data.

Vignettes:

* https://www.bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html
* https://bioconductor.org/packages/devel/data/experiment/vignettes/celldex/inst/doc/userguide.html#23_Mouse_RNA-seq

```{r}
library(SingleR)
library(pheatmap)

# Built-in reference mouse dataset
mouse_se = MouseRNAseqData() # inclusion in singleR is deprecated, obtain from celldex

# Convert gene names
test_counts = assay(sce, "logcounts")
tx2gene = readRDS(here("mouse_cortex", "salmon_files", "gencode.vM25.annotation.tx2gene.mouse.rds"))
match_rows = match(rownames(test_counts), tx2gene$gene_id)
rownames(test_counts) = tx2gene$gene_name[match_rows]

pred_celltypes = SingleR(test = test_counts, 
                         ref = mouse_se,
                         labels = mouse_se$label.fine)

# Plot
all.markers <- metadata(pred_celltypes)$de.genes

# Add to colData
colData(sce)$singleR_labels = pred_celltypes$labels
colData(sce)$singleR_labels_pruned = pred_celltypes$pruned.labels
colData(sce)$singleR_main_labels = colData(sce) %>% 
  as_tibble() %>%
  select(singleR_labels) %>%
  left_join(., as_tibble(colData(mouse_se)) %>% distinct(), by = c("singleR_labels" = "label.fine")) %>%
  select(label.main)

# Built-in plots
# plotScoreHeatmap(pred_celltypes)
# features = unique(unlist(all.markers$Astrocytes))
# features = tx2gene %>% filter(gene_name %in% features) %>% pull(gene_id) %>% unique()
# plotHeatmap(sce[, which(colData(sce)$ding_labels == "Astrocyte")], # Need to run ding section first
#             order_columns_by = "singleR_labels_pruned",
#             features = features,
#             fontsize_row = 1) # takes a while to run if too many cells/genes
```

```{r}
# PCA colored by singleR labels
plotReducedDim(sce, "PCA", colour_by = "singleR_labels_pruned")
```


#### Ding

> We used marker genes for each cell type to compute a score for each cell and automatically assign cell types to clusters.

```{r}
meta_ding = read_tsv(here("mouse_cortex", "files", "meta_combined.txt"))
meta_ding_10x = meta_ding %>%
  filter(Method == "10x Chromium") %>%
  mutate(cell_barcode = gsub("Cortex.*10xChromium", "", NAME))
match_cols = match(colnames(sce), meta_ding_10x$cell_barcode)
colData(sce)$ding_labels = meta_ding_10x$CellType[match_cols]

# preandmrna_cd = colData(sce)
# transcripts_cd = colData(sce)
# introncollapse_cd = colData(sce)
```

```{r}
# PCA colored by Ding's labels
plotReducedDim(sce, "PCA", colour_by = "ding_labels")
```

```{r}
# Get overlap with singleR labels
tb = as_tibble(introncollapse_cd)
overlap = table(tb$singleR_labels_pruned, tb$ding_labels, useNA = "ifany") %>%
  as.data.frame()

# Normalize frequency within each Ding cell type
overlap = overlap %>%
  group_by(Var2) %>%
  mutate(Freq_norm = Freq/sum(Freq)) %>%
  ungroup()

# Plot
overlap %>%
  ggplot(aes(x = Var1, y = Var2, fill = Freq)) + 
  scale_fill_gradient(low="white", high="blue") +
  geom_tile() +
  labs(x = "singleR_labels_pruned",
       y = "ding_labels") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

overlap %>%
  ggplot(aes(x = Var1, y = Var2, fill = Freq_norm)) + 
  scale_fill_gradient(low="white", high="blue") +
  geom_tile() +
  labs(x = "singleR_labels_pruned",
       y = "ding_labels") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

```{r}
tb = as_tibble(preandmrna_cd) %>%
  mutate(cell = rownames(preandmrna_cd))

# Label cells where singleR label != ding label
tb = tb %>%
  mutate(ding_labels_match = case_when(ding_labels == "Astrocyte" ~ "Astrocytes",
                                       ding_labels == "Endothelial" ~ "Endothelial cells",
                                       ding_labels == "Excitatory neuron" ~ "Neurons",
                                       ding_labels == "Inhibitory neuron" ~ "Neurons",
                                       ding_labels == "Oligodendrocyte" ~ "Oligodendrocytes",
                                       T ~ ding_labels))

tb = tb %>%
  mutate(singleR_labels_match = case_when(singleR_labels_pruned == "Astrocytes activated" ~ "Astrocytes",
                                          singleR_labels_pruned == "Fibroblasts activated" ~ "Fibroblasts",
                                          singleR_labels_pruned == "Fibroblasts senescent" ~ "Fibroblasts",
                                          singleR_labels_pruned == "Macrophages activated" ~ "Macrophages",
                                          singleR_labels_pruned == "Microglia activated" ~ "Microglia",
                                          singleR_labels_pruned == "Neurons activated" ~ "Neurons",
                                          T ~ singleR_labels_pruned),
         non_matching_cells = (singleR_labels_match != ding_labels_match) | (is.na(singleR_labels_match) & !is.na(ding_labels_match)))

tb_misclassify = tb %>%
  filter(!is.na(ding_labels_match)) 

tb_misclassify %>%
  ggplot(aes(x = lib_size)) +
  geom_histogram(aes(fill = non_matching_cells)) +
  facet_wrap(~ ding_labels_match, nrow = 2, scales = "free") +
  labs(title = "preandmrna pipeline") +
  theme_bw()

print(sum(tb_misclassify$non_matching_cells, na.rm = T))

tb_misclassify
```

#### Differences between pipelines

```{r}
# Counts for marker genes
astrocyte_mg = unique(unlist(all.markers$Astrocytes))
genes_in_type = t2g %>% filter(gene_name %in% astrocyte_mg) %>% pull(gene_id)
cd = colData(sce) %>% as_tibble() %>% mutate(cell = rownames(colData(sce)))
astrocyte_cells = cd %>% filter(ding_labels == "Astrocyte") %>% pull(cell)
astrocyte_matrix = counts(sce)[genes_in_type, astrocyte_cells] # Astrocyte cells and astrocyte marker genes only
# rowSums(astrocyte_matrix)
colSums(astrocyte_matrix) %>% 
  as_tibble() %>%
  mutate(cell = colnames(astrocyte_matrix)) %>%
  left_join(., cd, by = "cell") %>%
  ggplot(aes(x = value)) +
  geom_histogram(aes(fill = singleR_labels_pruned)) +
  theme_bw()
```

```{r}
# genes_in_type = names(sort(-rowSums(astrocyte_matrix))[3]) # Choose a specific gene
gene_type_name = "Astrocyte"
gene_sum_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  
  lib_size_tb = tibble(cell_barcode = astrocyte_cells)
  lib_size_gene_type = colSums(counts(sce_i)[intersect(rownames(counts(sce_i)), genes_in_type), astrocyte_cells, drop = F])
  lib_size_gene_type_tb = tibble(cell_barcode = names(lib_size_gene_type),
                                 !!gene_type_name := lib_size_gene_type)
  lib_size_tb = lib_size_tb %>% 
    left_join(., lib_size_gene_type_tb, by = "cell_barcode")
  gene_sum_tb_ls[[pipeline_name]] = lib_size_tb %>%
    pivot_longer(cols = -cell_barcode) %>%
    mutate(pipeline = pipeline_name)
}
gene_sum_tb = bind_rows(gene_sum_tb_ls)
gene_sum_tb = gene_sum_tb %>%
  pivot_wider(names_from = pipeline, values_from = value)
```

```{r}
# Plot comparison of marker genes for cell type across pipelines
gene_sum_tb %>%
  ggplot(aes(x = transcripts, y = preandmrna)) + 
  geom_point(size = 0.1, alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~ name, scales = "free") +
  labs(x = "num_reads_transcripts",
       y = "num_reads_preandmrna") +
  theme_bw()

# Boxplot
gene_sum_tb_2 = gene_sum_tb %>%
  pivot_longer(-c("cell_barcode", "name"), names_to = "pipeline", values_to = "counts")
summ <- gene_sum_tb_2 %>% 
  group_by(pipeline) %>% 
  summarize(median = median(counts))
gene_sum_tb_2 %>%
  ggplot(aes(x = pipeline, y = counts)) +
  geom_boxplot() +
  geom_label(data = summ, aes(x = pipeline, y = median, 
                              label = round(median, 0))) +
  theme_bw() 
```

```{r}
# Plot ratio of astrocyte:qNSC marker genes for astrocyte cells between pipelines
astrocyte_mg = unique(unlist(all.markers$Astrocytes))
astrocyte_genes = t2g %>% filter(gene_name %in% astrocyte_mg) %>% pull(gene_id)
qnsc_mg = unique(unlist(all.markers$qNSCs))
qnsc_genes = t2g %>% filter(gene_name %in% qnsc_mg) %>% pull(gene_id)

gene_type_name = "Astrocyte qNSC ratio"
gene_sum_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  
  lib_size_tb = tibble(cell_barcode = astrocyte_cells)
  lib_size_gene_type_astrocyte = colSums(counts(sce_i)[intersect(rownames(counts(sce_i)), astrocyte_genes), astrocyte_cells, drop = F])
  lib_size_gene_type_qnsc = colSums(counts(sce_i)[intersect(rownames(counts(sce_i)), qnsc_genes), astrocyte_cells, drop = F])
  lib_size_gene_type_tb = tibble(cell_barcode = names(lib_size_gene_type),
                                 !!gene_type_name := lib_size_gene_type_astrocyte/lib_size_gene_type_qnsc)
  lib_size_tb = lib_size_tb %>% 
    left_join(., lib_size_gene_type_tb, by = "cell_barcode")
  gene_sum_tb_ls[[pipeline_name]] = lib_size_tb %>%
    pivot_longer(cols = -cell_barcode) %>%
    mutate(pipeline = pipeline_name)
}
gene_sum_tb = bind_rows(gene_sum_tb_ls)
gene_sum_tb = gene_sum_tb %>%
  pivot_wider(names_from = pipeline, values_from = value)

# Plot comparison of marker genes for cell type across pipelines
gene_sum_tb %>%
  ggplot(aes(x = transcripts, y = preandmrna)) + 
  geom_point(size = 0.1, alpha = 0.5) +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(~ name, scales = "free") +
  labs(x = "num_reads_transcripts",
       y = "num_reads_preandmrna") +
  theme_bw()
```
```{r}
# Boxplot
gene_sum_tb_2 = gene_sum_tb %>%
  pivot_longer(-c("cell_barcode", "name"), names_to = "pipeline", values_to = "counts")
summ <- gene_sum_tb_2 %>% 
  group_by(pipeline) %>% 
  summarize(median = median(counts))
gene_sum_tb_2 %>%
  left_join(., cd, by = c("cell_barcode" = "cell")) %>%
  ggplot(aes(x = pipeline, y = counts)) +
  geom_boxplot() +
  geom_label(data = summ, aes(x = pipeline, y = median, 
                              label = round(median, 2))) +
  facet_wrap(~ singleR_labels_pruned) +
  labs(caption = "Cell types labels assigned by singleR under transcripts pipeline") +
  theme_bw() 
```


```{r}
# Find genes that are most different between pipelines
gene_diff_tb_ls = list()
for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  gene_diff_tb_ls[[i]] = tibble(pipeline = pipeline_name,
                            gene_id = rownames(counts(sce_i)),
                            sum = rowSums(counts(sce_i)))
}

gene_diff_tb = bind_rows(gene_diff_tb_ls) %>%
  pivot_wider(names_from = pipeline, values_from = sum) %>%
  left_join(., t2g %>% select(gene_id, gene_name), by = "gene_id") %>% # Join to gene name
  mutate(diff = (preandmrna - transcripts)/preandmrna) %>%             # Calculate percent increase from transcripts to preandmrna
  arrange(-diff) %>%                                                   # Arrange by difference
  filter(complete.cases(.))                                            # Remove rows with NA (e.g. genes that are not present in all pipelines)


# Markers for all genes
all_marker_genes_tb_ls = list()
for(cell_type in names(all.markers)){
  all_marker_genes_tb_ls[[cell_type]] = tibble(cell_type = cell_type,
                                               gene_name = unique(unlist(all.markers[[cell_type]])))
}
all_marker_genes_tb = bind_rows(all_marker_genes_tb_ls)
gene_diff_plt = gene_diff_tb %>%
  left_join(., all_marker_genes_tb, by = "gene_name") %>%
  filter(complete.cases(.)) %>%     # Remove genes that are not marker genes
  mutate(group = ceiling((1:n())/1000)) # Assign group for every 1000 genes

# Summary statistics (median difference for each group)
gene_diff_plt %>% 
  group_by(group) %>%
  summarize(median_diff = median(diff)) %>%
  ungroup(group) %>%
  ggplot(aes(x = group, y = median_diff)) +
  geom_bar(stat = "identity") +
  scale_x_continuous(breaks = 1:9) +
  theme_bw()
```

```{r fig.height = 10, fig.width = 8}
library(tidytext) # for reorder_within
# Plot distribution of marker genes for each group 
gene_diff_plt %>%
  group_by(cell_type, group) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  ggplot(aes(x = reorder_within(cell_type, -count, group), y = count)) + 
  geom_bar(stat = "identity") +
  facet_wrap(~ group, scales = "free_x", labeller = label_both) +
  labs(x = "Cell type marker genes",
       title = "Distribution of marker genes grouped by difference between pipelines") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


gene_diff_plt %>%
  group_by(cell_type, group) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  ggplot(aes(x = group, y = count)) + 
  geom_bar(stat = "identity") +
  facet_wrap(~ cell_type, scales = "free_x") +
  scale_x_continuous(breaks = 1:9) +
  labs(x = "Cell type marker genes",
       title = "Distribution of marker genes across the groups") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```



```{r}
# Plot lib size for different cell types
lib_size_tb = tibble(cell_barcode = colnames(sce_ls[[1]]),
                     ding_labels = colData(sce)$ding_labels)

for(i in seq_along(sce_ls)){
  pipeline_name = names(sce_ls)[i]
  sce_i = sce_ls[[i]]
  
  lib_size = colSums(counts(sce_i))
  lib_size_pipeline_tb = tibble(cell_barcode = colnames(sce_i),
                       !!paste0("lib_size_", pipeline_name) := lib_size)
  lib_size_tb = lib_size_tb %>%
    left_join(., lib_size_pipeline_tb, by = "cell_barcode")
}

lib_size_tb %>%
  ggplot(aes(x = lib_size_transcripts, y = lib_size_preandmrna, color = ding_labels), alpha = 0.5) + 
  facet_wrap(~ ding_labels) + 
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  theme_bw()
```



### Distributions

To assess distributions, we want to obtain a homogenous group of cells.

```{r}
# Subset to cluster
cell_type = "Inhibitory neuron"
counts_sub = as.matrix(assay(sce, "counts")[, (colData(sce)$ding_labels == cell_type & !is.na(colData(sce)$ding_labels))])
counts_sub = counts_sub[rowSums(counts_sub) != 0, ]
dim(counts_sub)
```

#### Within-group clustering

```{r}
sce_sub = SingleCellExperiment(assays=list(counts = counts_sub))
# Normalize and take log
clust = quickCluster(sce_sub)
sce_sub = computeSumFactors(sce_sub, clusters = clust)
sce_sub = logNormCounts(sce_sub)

set.seed(1)
tic("approx PCA")
sce_sub = runPCA(sce_sub, exprs_values = "logcounts", ntop = ncol(sce), BSPARAM = RandomParam())
toc()
```

```{r eval = F}
# K-means clustering
set.seed(1)

# Elbow plot with SSE
sse = c()
for(k in 1:10){
  clust.kmeans <- kmeans(reducedDim(sce_sub, "PCA"), centers = k)
  sse = c(sse, clust.kmeans$tot.withinss)
}
plot(sse)

clust.kmeans <- kmeans(reducedDim(sce_sub, "PCA"), centers = 4)
colData(sce_sub)$labels_kmeans <- factor(clust.kmeans$cluster)
plotReducedDim(sce_sub, "PCA", colour_by = "labels_kmeans", ncomponents = c(1, 2))
```

```{r eval = F}
# Graph-based clustering
g <- buildSNNGraph(sce_sub, k=10, use.dimred = 'PCA')
clust <- igraph::cluster_walktrap(g)$membership

colData(sce_sub)$labels_gb <- factor(clust)
plotReducedDim(sce_sub, "PCA", colour_by="labels_gb")
```

#### Proportion of zero plots

First, I make all the column sums comparable by downsampling (this is a stochastic transformation as opposed to scaling).

```{r}
summary(colSums(counts_sub))

# Source: https://github.com/willtownes/scrna2019/blob/028363f04139a58b19143f3058ca8fa4a3533b63/util/functions.R
Down_Sample_Matrix<-function(expr_mat,min_lib_size=NULL){
  min_sz<-min(colSums(expr_mat))
  if(is.null(min_lib_size)){
    min_lib_size<-min_sz
  } else {
    stopifnot(min_lib_size<=min_sz)
  }
  down_sample<-function(x){
    prob <- min_lib_size/sum(x)
    unlist(lapply(x,function(y){rbinom(1, y, prob)}))
  }
  apply(expr_mat, 2, down_sample)
}


counts_sub_scaled = Down_Sample_Matrix(ceiling(counts_sub))
counts_sub_scaled = counts_sub_scaled[rowSums(counts_sub_scaled) != 0, ]
summary(colSums(counts_sub_scaled))
```

I compute the average expression for every row (x-axis) $\hat{\mu}_i$ and the empirical $P(X_i=0)$, which is the probability that for a given transcript $i$, the count is 0. 

I then compute what $P(X_i=0)$ would be under the model assumptions of binomial or poisson, using parameters estimated from the data. In particular, for a $Binom(n, p_i)$, $n$ is the median number of total counts of cells and $p_i$ is the proportion of counts that were in gene $i$.

```{r}
# Function to plot P(X_i = 0) against average expression level mu_i
plot_prob = function(dat_sub){
  n = round(median(colSums(dat_sub)))
  means = rowMeans(dat_sub)
  vars = apply(dat_sub, MARGIN = 1, var)
  
  # empirical P(X_i = 0)
  emp_probs_0 = apply(dat_sub, MARGIN = 1, function(r) sum(r==0)/ncol(dat_sub))
  plot_dt = tibble(means, emp_probs_0)
  
  emp_props = rowSums(dat_sub)/sum(colSums(dat_sub))
  # Model P(X_i = 0) under Binomial
  binom_probs_0 = dbinom(x = 0, size = n, prob = emp_props)
  # Model P(X_i = 0) under Poisson
  poiss_probs_0 = dpois(x = 0, lambda = n*emp_props)
  # Model P(X_i = 0) under Negative Binomial
  # Estimate size/dispersion parameter
  model = lm(vars ~ 1*means + I(means^2) + 0, tibble(means, vars))
  phi = 1/coef(model)["I(means^2)"]
  nbinom_probs_0 = dnbinom(x = 0, size = phi, mu = n*emp_props) 
  
  # Tibble for plot
  plot_lines_dt = tibble(means = means,
                         binomial = binom_probs_0,
                         poisson = poiss_probs_0,
                         nbinomial = nbinom_probs_0) %>%
    pivot_longer(-means, names_to = "model", values_to = "probs_0")
  
  # Plot
  plt = plot_lines_dt %>%
    ggplot(aes(x = log(means), y = probs_0)) +
    geom_point(data = plot_dt, aes(x = log(means), y = emp_probs_0), alpha = 0.4) + # Add data points
    geom_line(aes(color = model),
              size = 0.5) + # Add lines for models
    labs(x = "Average expression level log(E(X_i))",
         y = "P(X_i = 0)") +
    theme_bw() +
    theme(text = element_text(size = 15))
  
  # Return object
  out = list(plot = plt,
             lines_dt = plot_lines_dt)
  return(out)
}
```

```{r}
# Plot P(X_i = 0) against average expression level
prob_out = plot_prob(counts_sub_scaled)
prob_out$plot +
  labs(title = cell_type)
```

#### Goodness-of-fit tests

There are 2 issues:

1) Why is quant matrix not all integers?
2) Why are NaNs produced/non-finite finite-difference value errors occur in fitdistr("negative binomial")?

```{r eval = F}
library(MASS)

# Poisson
tic()
p_values_pois = c()
for(i in 1:nrow(counts_sub_scaled)){
  # message(i)
  x = counts_sub_scaled[i,]
  x = ceiling(x) 
  poissonfit = fitdistr(x, "poisson")
  lambda.fit = poissonfit$estimate["lambda"]
  nsamples = length(x)
  f.obs = table(x)
  bins = as.numeric(names(f.obs))
  f.hyp = dpois(bins, lambda = lambda.fit)*nsamples
  chiSquare.pois = sum((f.obs-f.hyp)^2/f.hyp)
  dof = length(bins) - 1
  p_values_pois = c(p_values_pois, 1 - pchisq(chiSquare.pois, df = dof))
}
toc()

# Negative binomial
tic()
p_values_nb = c()
for(i in 1:nrow(counts_sub_scaled)){
  # message(i)
  tryCatch({
  x = counts_sub_scaled[i,]
  x = ceiling(x)
  nbfit = suppressWarnings(fitdistr(x, "negative binomial"))
  r.fit = nbfit$estimate['size']
  p.fit = r.fit / (nbfit$estimate['mu'] + r.fit)
  nsamples = length(x)
  f.obs = table(x)
  bins = as.numeric(names(f.obs))
  f.hyp = dnbinom(bins, size = r.fit, prob = p.fit)*nsamples
  chiSquare.nb = sum((f.obs-f.hyp)^2/f.hyp)
  dof = length(bins) - 1
  p_values_nb = c(p_values_nb, 1 - pchisq(chiSquare.nb, df = dof))}, error = function(e){})
}
toc()

# Put p-values in tibble
print(length(p_values_pois) - length(p_values_nb))
p_value_tb = tibble(distribution = c(rep("Poisson", length(p_values_pois)), rep("NB", length(p_values_nb))),
       p_value = c(p_values_pois, p_values_nb),
       gene = rep(rownames(counts_sub_scaled), 2))

# Histogram of p-values
p_value_tb %>%
  ggplot(aes(x = p_value)) + 
  geom_histogram() +
  facet_wrap(~ distribution) +
  labs(title = cell_type) +
  theme_bw()

# Scatterplot of p-values
emp_probs_0 = apply(counts_sub_scaled, MARGIN = 1, function(r) sum(r==0)/ncol(counts_sub_scaled))
p_value_tb %>%
  pivot_wider(id_cols = gene,
              names_from = "distribution",
              values_from = "p_value") %>%
  mutate(emp_probs_0 = emp_probs_0) %>%
  ggplot(aes(x = Poisson, y = NB)) + 
  geom_point(aes(color = emp_probs_0), alpha = 0.5) +
  labs(x = "poisson_pvalue",
       y = "nb_pvalue") +
  theme_bw()
```


#### BIC log-likelihood

Source: https://github.com/willtownes/scrna2019/blob/028363f04139a58b19143f3058ca8fa4a3533b63/util/functions.R

```{r eval = F}
# Helper functions
# Multinomial
mult_bic<-function(m){
  #multinomial model
  n<-colSums(m)
  p<-rowSums(m)/sum(n)
  ll<-sum(apply(m,2,dmultinom,prob=p,log=TRUE))
  df<-nrow(m)-1
  print(paste0("Loglikelihood is ", ll, " df is ", df))
  -2*ll+df*log(prod(dim(m)))
}

# Dirichlet multinomial (for overdispersion)
dmn_bic<-function(m){
  fit<-DirichletMultinomial::dmn(t(m),1)
  alpha<-drop(fit@fit$Estimate)
  ll<-sum(extraDistr::ddirmnom(t(m), colSums(m), alpha, log = TRUE))
  df = nrow(m)
  print(paste0("Loglikelihood is ", ll, " df is ", df))
  -2*ll+nrow(m)*log(prod(dim(m)))
}

# Poisson
poi_fit<-function(m,X=NULL,sz=NULL,maxit=100){
  #poisson
  if(is.null(sz)){ sz<-log(colMeans(m)) }
  if(is.null(X)){ #no covariates => closed form solution
    sz<-exp(sz) # sz is library size / number of genes = colMeans(m)
    lam<-rowSums(m)/sum(sz) # each gene has an empirically estimated lambda (~ proportion of counts in that gene)
    mu<-outer(lam,sz) # outer product of lambda and sz (equivalent to prop of counts in gene * library size), each cell x gene has a mu
    ll<-matrix(dpois(m,mu,log=TRUE),nrow=nrow(m)) # Calculate loglikelihood in every cell x gene
    return(data.frame(ll=rowSums(ll),converged=TRUE)) # Sum loglikelihoods in each row
  } else { #covariates included
    stopifnot(all(X[,1]==1))
    k<-ncol(X)
    fam<-poisson()
    #default maxit is 25 for glm.fit, but some fits take longer to converge
    ctl<-list(maxit=maxit) 
    f<-function(y){
      fit<-glm.fit(X,y,offset=sz,control=ctl,family=fam)
      c(ll=k-fit$aic/2, converged=fit$converged)
    }
    res<-as.data.frame(t(apply(m,1,f)))
    res$converged<-as.logical(res$converged)
    return(res)
  }
}

poi_bic<-function(m,X=NULL,prefit=NULL,maxit=100){
  #poisson. prefit should be a data frame with column "ll" for log-likelihood
  k<-if(is.null(X)){ 1 } else { ncol(X) }
  df<-k*nrow(m)
  if(is.null(prefit)){
    prefit<-poi_fit(m,X,maxit=maxit)
  }
  ll<-sum(prefit$ll) # Sum the sums of loglikelihoods across genes
  #compute BIC: -2*loglik+df*log(n_obs)
  print(paste0("Loglikelihood is ", ll, " df is ", df))
  -2*ll+df*log(prod(dim(m)))
}

# Negative binomial (single overdispersion parameter for all genes)
nb_bic_1 = function(m){
  # estimate phi
  means = rowMeans(m)
  vars = apply(m, MARGIN = 1, var)
  model = lm(vars ~ 1*means + I(means^2) + 0, tibble(means, vars))
  phi = 1/coef(model)["I(means^2)"]
  
  # estimate mu
  sz <- colMeans(m) # sz is library size / number of genes = colMeans(m)
  lam <- rowSums(m)/sum(sz) # each gene has an empirically estimated lambda (~ proportion of counts in that gene)
  mu <- outer(lam, sz) # outer product of lambda and sz (equivalent to prop of counts in gene * library size), each cell x gene has a mu
  
  # get ll
  ll = matrix(dnbinom(m, size = phi, mu = mu, log = TRUE), nrow = nrow(m)) # get likelihood for every cell x gene
  ll = sum(ll) # sum likelihood
  df = nrow(m) + 1
  print(paste0("Loglikelihood is ", ll, " df is ", df))
  -2*ll+df*log(prod(dim(m)))
}

# Negative binomial (separate overdispersion parameter for each gene)
nb_fit<-function(m,X=NULL,sz=NULL){
  #neg binom
  if(is.null(sz)){ sz<-log(colMeans(m))} 
  if(is.null(X)){
    f<-function(y){
      mgcv::gam(y~1,family=mgcv::nb,offset=sz,method="ML") # Each cell is a different observation for a given gene (y = one row of m)
    }
  } else {
    f<-function(y){
      mgcv::gam(y~X-1,family=mgcv::nb,offset=sz,method="ML")
    }
  }
  g<-function(y){
    fit<-f(y)
    th<-fit$family$getTheta(TRUE) #FALSE (default) gives log(theta)
    ll<-as.numeric(logLik(fit))
    c(theta=th,ll=ll,converged=fit$converged) # different theta for every gene
  }
  res<-as.data.frame(t(apply(m,1,g)))
  res$converged<-as.logical(res$converged)
  res
}

nb_bic_2<-function(m,X=NULL,prefit=NULL){
  if(is.null(prefit)){ 
    prefit<-nb_fit(m,X)
  } else {
    stopifnot(nrow(m)==nrow(prefit))
  }
  ll<-sum(prefit$ll)
  k<-if(is.null(X)){ 2 } else { ncol(X)+1 }
  df = k*nrow(m)
  print(paste0("Loglikelihood is ", ll, " df is ", df))
  -2*ll+df*log(prod(dim(m)))
}
```

```{r eval = F}
m = counts_sub_scaled
m = ceiling(m)
summary(colSums(m))
summary(rowSums(m))
m = m[rowSums(m) != 0, ]
dim(m)

bic_tb = tibble(multinomial = mult_bic(m),     # 5 sec
                # dmn = dmn_bic(m),     # Unknown time, need to run as script on cluster
                poisson = poi_bic(m),       # 5 sec
                negative_binomial_1 = nb_bic_1(m),     # 5 sec
                negative_binomial_2 = nb_bic_2(m),   # 15 min
                cell_type_name = cell_type)

# Plot
bic_tb %>% 
  pivot_longer(cols = -cell_type_name) %>%
  ggplot(aes(x = reorder(name, value), y = value)) +
  geom_point(size = 3) +
  labs(title = ,
       x = "Distribution",
       y = "BIC") +
  theme_bw()
```



#### Poisson-Gamma models

Using `glmGamPoi` to plot mean-variance relationships.

```{r}
library(glmGamPoi)

# Empirical mean and variance
mean_emp = rowMeans(counts_sub_scaled)
var_emp = genefilter::rowVars(counts_sub_scaled)

# Poisson
fit_pois = glmGamPoi::glm_gp(counts_sub_scaled, design = ~ 1, size_factors = FALSE, 
                         overdispersion = FALSE)
# Negative binomial
# Estimate overall size/dispersion parameter
model = lm(var_emp ~ 1*mean_emp + I(mean_emp^2) + 0, tibble(mean_emp, var_emp))
phi = 1/coef(model)["I(mean_emp^2)"]

# Estimate size/dispersion parameter for every gene
fit_nb =  glmGamPoi::glm_gp(counts_sub_scaled, design = ~ 1, size_factors = FALSE, 
                         overdispersion = TRUE)

# Note: rowMean(fit_pois$Mu) = rowMeans(fit_nb$Mu) = rowMeans(counts)
mean_var_tb = tibble(mean_emp = mean_emp,
                     var_emp = var_emp,
                     var_pois = rowMeans(counts_sub_scaled),
                     var_nb_v1 = mean_emp + mean_emp^2 * 1/phi, 
                     var_nb_v2 = mean_emp + mean_emp^2 * fit_nb$overdispersions) %>% 
  tidyr::pivot_longer(cols = -mean_emp, names_to = "var_type", values_to = "var_value")

# Plot
mean_var_tb %>%
  filter(var_type %in% c("var_emp", "var_nb_v1")) %>%
  ggplot(aes(x = mean_emp, y = var_value, color = var_type)) + 
  geom_point(alpha = 0.1) + 
  scale_x_log10() + scale_y_log10() +
  theme_bw()
```

